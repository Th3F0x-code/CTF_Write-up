from gmpy2 import *
from Crypto.Util.number import *


def next_prime(n):
    tmp = n
    while tmp + 1000 > n:
        n += 1
        if is_prime(n):
            primes.append(n)


def find_pq(primes):
    for p in primes:
        for q in primes:
            if p * q == n:
                return p, q


n = 137866207154126841926135173451358115364278213684521572523358907639756849267625989203803139156255011696944207127190680285326855425852764146184626857091525539105016966652616046475290899093074083795277502910801200926744561269527098028426269373323424980295041083818220821875656945269376954220805993190237542387003
e = 65537
c = 67932802035805588854278977673045833517593273239942847623689503474317866628886199433810017197037291176343627455376241464624870557830239851446861917867043000728823054049444875946790685574440463627283062014107345418490148867942084538625043907585104640830388180234446782401778750812259071969890168545489104373218

primes = []

# iroot(n, 2) -> p * q sono strettamente correlati
p = 11741644141862196716288294734556791281375506026500927629354856132439964706815203188997201694574048955072193942782820729148650947367698067189279934438560797

next_prime(p - 500)
p, q = find_pq(primes)

phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
m = pow(c, d, n)

print(long_to_bytes(m).decode())
